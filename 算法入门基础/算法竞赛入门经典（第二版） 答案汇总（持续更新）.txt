求int的上限与下限
#include <stdio.h>
//运行时间长,请等待. 
int main()
{
 int min ,max;
 FILE *fin,*fout;
 fin=fopen("min of int.out","wb");
 fout=fopen("max of int.out","wb");
 for(min=-1;min<0;)
 {
        min--   ;      
 }
 fprintf(fin,"%d\n",min+1);
 for(max=1;max>0;)
 {
        max++   ;      
 }
 fprintf(fout,"%d\n",max-1);
 fclose(fin);
 fclose(fout);
 return 0;
 }
1-1
#include <stdio.h>
int main()
{
    int a,b,c;
    scanf("%d%d%d",&a,&b,&c);
    double average;
    average=(a+b+c)/3.0; //一定要将int型转为浮点型 
    printf("Average=%.3lf",average ); 
    system("pause");
    return 0; 
}
1-2
#include <stdio.h>
int main()
{
    double f,c;
    printf("请输入华氏温度f\n"); 
    scanf("%lf",&f);
    c=(f-32)*5/9 ; 
    printf("摄氏温度c=%.3lf\n",c); 
    system("pause"); 
    return 0; 
}
1-3
#include <stdio.h>
int main()
{
    int n;
    scanf("%d",&n);
    printf("%d\n",(1+n)*n/2) ;
    system("pause"); 
    return 0; 
}
1-4
#include <stdio.h>
#include <math.h> 
int main()
{
    const double pi =4.0*atan(1.0); 
    int n;
    scanf("%d",&n); 
    while(n>=360)
    {
                 printf("请输入小于360°的角\n");
                 scanf("%d",&n); 
    }
    
    printf("正弦:%lf\n余弦:%lf",sin(n*pi/180),cos(n*pi/180)); 
    system("pause"); 
    return 0; 
}
1-5
#include <stdio.h>
#include <math.h> 
int main()
{
    double x1,y1,x2,y2;
    printf("请输入点A的坐标\n"); 
    scanf("%lf%lf",&x1,&y1); 
    printf("请输入点B的坐标\n");
    scanf("%lf%lf",&x2,&y2);
    double d;
    d=sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2)); 
    printf("%.3lf\n",d); 
    system("pause");
    return 0; 
}
1-6
#include <stdio.h>
int main()
{
    int a;
    scanf("%d",&a); 
    if(a%2==0)printf("该数是偶数");
    else printf("该数非偶数"); 
    system("pause");
    return 0; 
}
1-7
#include <stdio.h>
int main()
{
    const int a=95; 
    int n;
    printf("你要买多少件衣服\n");
    scanf("%d",&n);
    if(a*n>=300)printf("需要%.2lf元\n",a*n*0.85);
    else printf("需要%.2lf元\n",(double)a*n); //由于输出是小数%.2lf,故一定要将int型转化为浮点型 
    system("pause");
    return 0; 
}
1-8
#include <stdio.h>
#include <stdio.h>
int main()
{
    double a;
    scanf("%lf",&a); 
    if(a>0)printf("%.2lf",a);
    else printf("%.2lf",-a);
    system("pause"); 
    return 0; 
}
1-9(方法一)
#include <stdio.h>
int main()
{
    int a,b,c,max,min,middle;
    scanf("%d%d%d",&a,&b,&c);
    while(a<0||b<0||c<0)
    {
           printf("三边必须都是大于零的正整数");
           scanf("%d%d%d",&a,&b,&c);             
    }
    min=a;if(a>b)min=b;if(a>c)min=c;
    max=a;if(a<b)max=b;if(a<c)max=c;
    middle=a+b+c-min-max;  
    if(min+middle>max)printf("yes");
    else printf("no");   
    system("pause");
    return 0; 
}
1-9(方法二)
#include <stdio.h>
int main()
{
    int a,b,c,t=0;
    scanf("%d%d%d",&a,&b,&c);
    while(a<0||b<0||c<0)
    {
           printf("三边必须都是大于零的正整数");
           scanf("%d%d%d",&a,&b,&c);             
    }
    
    if(a>b){t=a;a=b;b=t;}
    if(a>c){t=a;a=c;c=t;}
    if(b>c){t=b;b=c;c=t;}
    if(a+b>c)printf("yes");
    else printf("no");   
    system("pause");
    return 0; 
}
1-10
#include <stdio.h>
int main()
{
    int n;
    scanf("%d",&n); 
    if(n%4==0)
    {
      if(n%100==0)
      {
        if(n%400==0)
        {
        printf("yes"); 
        }          
        else printf("no"); 
      }        
      else printf("yes"); 
    } 
    else printf("no"); 
    system("pause");
    return 0; 
}
3n+1解决篇1
#include <stdio.h> 
int  main()
{
    int count=0;double i,m;
    
    scanf("%lf",&i);
    for(;i>1;)
    {
         m=i/2;    
         if(floor(m+0.5)!=m){i=3*i+1;i/=2;count+=2;}//floor(x)取x的整数部分. 
         else {i/=2;count++;}
    }
    printf("%d\n",count);
    system("pause");
    return 0;   
}
3n+1解决篇2
#include<stdio.h>
int main(){
  long long n, count = 0;//long long 的取值范围:-2^63~2^63-1
  scanf("%I64d", &n);
  while(n > 1) {
    if(n % 2 == 1) n = n*3+1;
    else n /= 2;
    count++;
  }
  printf("%I64d\n", count);
  return 0;
}
数据统计解决篇
#include <stdio.h> 
int  main()
{
    int x,n=0,s=0,min,max;
    while(scanf("%d",&x)==1)
    {
    if(n==0){min=max=x;}//读取第一个数的时候将第一个数赋值给min和max 
    s+=x;
    if(x<min)min=x;
    if(x>max)max=x;
    n++;
    }
    printf("%d %d %.3lf\n",min,max,(double)s/n);
    system("pause");
    return 0;   
}
2-1(fin)
#include <stdio.h>
int main()
{
    FILE *fin,*fout;
    fin=fopen("digit.in","rb");
    fout=fopen("digit.out","wb");
    /*fin=stdin;
    fout=stdout;*/
    int a,i=0;
    fscanf(fin,"%d",&a);
    while(1)
    {
           a/=10;
           i++;
           if(a<1)break;
    }
    fprintf(fout,"%d\r\n",i);
    fclose(fin);
    fclose(fout);
    //system("pause");
    return 0;
}
2-1(freopen)
#include <stdio.h>
//#define LOCAL//在编译选项中定义LOCAL 
int main()
{
    #ifdef LOCAL
    freopen("digit.in","r",stdin);
    freopen("digit.out","w",stdout);
    #endif
    int a,i=0;
    scanf("%d",&a);
    while(1)
    {
           a/=10;
           i++;
           if(a<1)break;
    }
    printf("%d\n",i);
    return 0;
}
2-2(freopen)
#include <stdio.h>
//#define LOCAL//编译选项中定义 
int main()
{
    #ifdef LOCAL
    freopen("daffodil.out","w",stdout);
    #endif
    int a,b,c,m;
    for(a=1;a<=9;a++)
    {
       for(b=0;b<=9;b++)
       {
           for (c=0;c<=9;c++)
           {
               m=a*100+b*10+c;
               if(m==a*a*a+b*b*b+c*c*c)printf("%d\n",m);
           }
       }
    }  
    //system("pause");
    return 0;  
}
2-2(fin)
#include <stdio.h>
int main()
{
    FILE *fout;
    fout=fopen("daffodil.out","wb");
    int a,b,c,m;
    for(a=1;a<=9;a++)
    {
         for(b=0;b<=9;b++)
         {
              for(c=0;c<=9;c++)
              {
                   m=a*a*a+b*b*b+c*c*c;
                   if(m==a*100+b*10+c)
                   fprintf(fout,"%d\r\n",m);
              }
         }
    }
    fclose(fout);
    return 0;
}
2-3(fin)
#include<stdio.h>
int main()
{
    FILE *fin,*fout;
    fin=fopen("hanxin.in","rb");
    fout=fopen("hanxin.out","wb");
    //fin=stdin;
    //fout=stdout;
    int a,b,c,x,temp=0;//temp用来判断是否在10到100内存在这样的数 
    fscanf(fin,"%d%d%d",&a,&b,&c);
    for(x=10;x<=100;x++)
    {
    if(x%3==a&&x%5==b&&x%7==c)
    {
    fprintf(fout,"%d\r\n",x);
    temp=1;
    break;
    }
    }
    if(!temp)fprintf(fout,"No answer\r\n");
    fclose(fin);
    fclose(fout);
    return 0;
}
2-3(freopen)

#include<stdio.h>
int main()
{
    //会在编译选项中定义LOCAL 
    #ifdef LOCAL
    freopen("hanxin.in","r",stdin);
    freopen("hanxin.out","w",stdout);
    #endif
    int a,b,c,x,temp=0;
    scanf("%d%d%d",&a,&b,&c);
    for(x=10;x<=100;x++)
    {
                if(x%3==a&&x%5==b&&x%7==c)
                {
                printf("%d\n",x);
                temp=1;
                break;
                }
    }
    if(!temp)printf("No answer\n");
    return 0;
}
2-4(fin)
#include<stdio.h>
int main()
{
    FILE *fin,*fout;
    fin=fopen("triangle.in","rb");
    fout=fopen("triangle.out","wb");
    //fin=stdin;
    //fout=stdout;
    int n,i,j,k;
    fscanf(fin,"%d\r\n",&n);
    for(i=1;i<=n;i++)
    {
                     for(j=1;j<i;j++)fprintf(fout," ");
                     for(k=-2*i+2*n+1;k>=1;k--)fprintf(fout,"*");
                     fprintf(fout,"\r\n");
    }
    fclose(fin);
    fclose(fout);
    return 0;
}
2-4(freopen)
#include<stdio.h>
int main()
{
    //在编译选项内定义LOCAL 
    #ifdef LOCAL
    freopen("triangle.in","r",stdin);
    freopen("triangle.out","w",stdout);
    #endif
    int n,i,j,k;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
                     for(j=1;j<i;j++)printf(" ");
                     for(k=2*n+1-2*i;k>=1;k--)printf("*");
                     printf("\n");
    }
    return 0;
}
2-5(fin)
#include<stdio.h>
int main()
{
    FILE *fin,*fout;
    fin=fopen("stat.in","rb");
    int n,a,i,m,count=0;    
    fscanf(fin,"%d",&n);
    for(i=1;i<=n+1;i++)
    {
                       fscanf(fin,"%d",&a);
                       if(i==n+1)m=a;
    }
    fclose(fin);
    fin=fopen("stat.in","rb");
    for(i=0;i<=n;i++)
    {
                     fscanf(fin,"%d",&a);
                     if(i!=0)
                     {
                             if(a<m)
                             count++;
                     }
    }
    fclose(fin);
    fout=fopen("stat.out","wb");
    fprintf(fout,"%d\r\n",count);
    fclose(fout);
    return 0;
}
2-5(freopen)
#include<stdio.h>
int main()
{
    freopen("stat.in","r",stdin);
    freopen("stat.out","w",stdout);
    int n,a,i,m,count=0;    
    scanf("%d",&n);
    for(i=1;i<=n+1;i++)
    {
                       scanf("%d",&a);
                       if(i==n+1)m=a;
    }
    
    freopen("stat.in","r",stdin);
    for(i=0;i<=n;i++)
    {
                     scanf("%d",&a);
                     if(i!=0)
                     {
                             if(a<m)
                             count++;
                     }
    }
    printf("%d\n",count);
    return 0;
}
2-6(fin)
#include<stdio.h>
int main()
{
    FILE *fin,*fout;
    fin=fopen("harmony.in","rb");
    int n,i;
    double H=0;
    fscanf(fin,"%d",&n);
    for(i=1;i<=n;i++)
    {
             H+=(double)1/i;        
    }
    fclose(fin);
    fout=fopen("harmony.out","wb");
    fprintf(fout,"%.3lf\r\n",H);
    fclose(fout);
    return 0;
}
2-6(freopen)
#include<stdio.h>
int main()
{
    #ifdef LOCAL
    freopen("harmony.in","r",stdin);
    freopen("harmony.out","w",stdout);
    #endif
    int n,i;
    double H=0;
    scanf("%d",&n);
    for(i=1;i<=n;i++)
    {
                     H=H+double/i;
    }
    printf("%.3lf",H);
    return 0;
}
2-7(fin)
#include<stdio.h>
int main()
{
    FILE *fout;
    int i;
    double H=0;
    for(i=1;2*i-1<1000000;i++)
    {
           if(i%2==1)H+=(double)1/(2*i-1);
           else H-=(double)1/(2*i-1);
                 
    }
    fout=fopen("approximation.out","wb");
    fprintf(fout,"%lf\r\n",H);
    return 0;
}
2-7(freopen)
#include<stdio.h>
int main()
{
    #ifdef LOCAL
    freopen("approximation.in","r",stdin);
    freopen("approximation.out","w",stdout);
    #endif
    int i;
    double H=0;
    for(i=1;2*i-1<1000000;i++)
    {
               if(i%2==1)H+=(double)1/(2*i-1);
               else H-=(double)1/(2*i-1);               
    }
    printf("%lf",H);
    return 0;
}
2-8(fin,double)
#include<stdio.h>
#include<time.h>
int main()
{
    FILE *fin,*fout;
    fin=fopen("subsequence.in","rb");
    fout=fopen("subsequence.out","wb");
    int n,m,i;
    double H=0;
    double ii;
    fscanf(fin,"%d%d",&n,&m);
    for(i=n;i<=m;i++)
    {
                     ii=(double)i*i;   
                     H+=1/ii;
    }
    fprintf(fout,"%.5lf\r\n",H);
    fprintf(fout,"%.2lf\r\n",(double)clock()/CLOCKS_PER_SEC);//比较double和long long运行效率 
    fclose(fin);
    fclose(fout);
    return 0;
    
}
2-8(fin,long long)
#include<stdio.h>
#include<time.h>
int main()
{
    FILE *fin,*fout;
    fin=fopen("subsequence.in","rb");
    fout=fopen("subsequence.out","wb");
    int n,m,i;
    double H=0;

    fscanf(fin,"%d%d",&n,&m);
    for(i=n;i<=m;i++)
    {
                     long long ii=1;//定义 
                     ii=ii*i*i; //不用ii=i*i也不是ii*=i*i,这样做是为了防止i*i溢出; 可以认为这一步将int型转化为long long 型 
                     H+=1/(double)ii;//不是(double)1/ii 
    }
    fprintf(fout,"%.5lf\r\n",H);
    fprintf(fout,"%.2lf\r\n",(double)clock()/CLOCKS_PER_SEC); ////比较double和long long运行效率 
    fclose(fin);
    fclose(fout);
    return 0;
    
}
2-8(freopen)
#include<stdio.h>
#define LOCAL
int main()
{
    #ifdef LOCAL
    freopen("subsequence.in","r",stdin);
    freopen("subsequence.out","w",stdout);
    #endif
    int n,m,i;
    double H=0,ii;
    scanf("%d%d",&n,&m);
    for(i=n;i<=m;i++)
    {
              
               H+=1/((double)i*i);       
    }
    printf("%.5lf\n",H);
    return 0;
}
2-9(fin)
#include<stdio.h>
int main()
{
    FILE *fin,*fout;
    fin=fopen("decimal.in","rb");
    fout=fopen("decimal.out","wb");
    int a,b,c;
    fscanf(fin,"%d%d%d",&a,&b,&c);
    fprintf(fout,"%.*lf\r\n",c,(double)a/b);
    fclose(fin);
    fclose(fout);
    return 0;
}
2-9(freopen)
#include<stdio.h>
int main()
{
    #ifdef LOCAL
    freopen("decimal.in","r",stdin);
    freopen("decimal.out","w",stdout);
    #endif
    int a,b,c;
    scanf("%d%d%d",&a,&b,&c);
    printf("%.*lf",c,(double)a/b);
    return 0;
}
2-10(全书看完再看这段代码)
#include<cstdio>
#include<algorithm>
using namespace std;
int main()
{
	freopen("permutation.ans","w",stdout);
	int d[]={1,2,3,4,5,6,7,8,9};
	do
	{
		int a=d[0]*100+d[1]*10+d[2];
		int b=d[3]*100+d[4]*10+d[5];
		int c=d[6]*100+d[7]*10+d[8];
		if(c==3*a&&b==2*a)printf("%d %d %d\n",a,b,c);
	}while(next_permutation(d,d+9));
	return 0;



算法竞赛入门经典（第二版） 答案汇总（持续更新）
震惊！居然还有这种好东西！！！

全部原创，如果发现可以改进或者有错（除了第二章没有在OJ上AC）的地方，由衷希望并感谢各位大佬、巨牛来改进程序，指出错误。互相学习，共同进步！

保持和书上一样二到四章（C语言实现（不用STL））; 后面（C++）。

注：书上的题目描述不全，这里就采用书上的简化版介绍。OJ是C11标准有的旧的函数等不能用！！！

NO BB, SHOW MY CODE!!!

第二章

习题2-1 水仙花数（ daffodil）
输出

输出100～ 999中的所有水仙花数。 若3位数ABC满足ABC＝ A3＋ B3＋ C3， 则称其为水仙花
数。 例如153＝ 13＋ 53＋ 33， 所以153是水仙花数。 

# include <iostream>
 
using namespace std;
 
int main(){
	int ABC = 100;
	for( ; ABC <= 999; ABC++){
		int A3, B3, C3;
		A3 = ABC / 100; B3 = ABC / 10 % 10; C3 = ABC % 10;
		if(ABC == A3*A3*A3 + B3*B3*B3 + C3*C3*C3)
			cout << ABC << ' ' ;
	}
	cout << endl;
	return 0;
}



习题2-2 韩信点兵（ hanxin）
相传韩信才智过人， 从不直接清点自己军队的人数， 只要让士兵先后以三人一排、 五人
一排、 七人一排地变换队形， 而他每次只掠一眼队伍的排尾就知道总人数了。 输入包含多组
数据， 每组数据包含3个非负整数a， b， c， 表示每种队形排尾的人数（ a＜ 3， b＜ 5， c＜
7） ， 输出总人数的最小值（ 或报告无解） 。 已知总人数不小于10， 不超过100。 输入到文件

结束为止。

# include <iostream>
# define LOCAL
using namespace std;
 
int main(){
/*	# ifdef LOCAL
		freopen("C:\\Users\\Administrator\\Desktop\\新建文本文档.txt", "r", stdin);
		freopen("C:\\Users\\Administrator\\Desktop\\新建文本文档2.txt", "w", stdout);
	# endif */
	int a, b, c, flag = 0, count = 0;
	while(cin >> a >> b >> c){
		count++;
		flag = 0;
		for(int i = 0; i < 34; i++){
			int num = 3 * i + a;
			if(num % 5 == b && num % 7 == c && num >0 && num < 100){
				cout << "Case " << count << ": " << num << endl;
				flag = 1;
			}
		}
		if(!flag)
			cout << "Case " << count << ": " << "NO answer!" << endl;
	}
}
 

习题2-3 倒三角形（ triangle）
输入正整数n≤20， 输出一个n层的倒三角形。 例如， n＝ 5时输出如下：
#########
#######
#####
###

#

# include <iostream>
using namespace std;
 
int main(){
	int n, k;
	cin >> n;
	k = 2*n-1;
	for(int i = 0; i < n; i++){
		for(int j = i; j > 0; j--){
			cout << ' ';
		}
		for( ; k > 0; k--){
			cout << "*";
		}
		k = 2*n-1 - (i+1)*2;
		cout << endl;
	} 
	return 0;
}



题2-4 子序列的和（ subsequence）
输入两个正整数n＜ m＜ 106， 输出 ， 保留5位小数。 输入包含多组数据，
结束标记为n＝ m＝ 0。 提示： 本题有陷阱。 

// 平方可能溢出，long long 或者 1 / n / n ; 
 
# include <iostream>
using namespace std;
 
int main(){
	long long n, m, count = 0;
	double sum = 0;
	while(cin >> n >> m){
		count++;
		if(n > m || (n == 0 && m == 0)){
			cout << "Case " << count  << ": " << "GG" << endl;
			return 0;
		}
		for(long long i = n; i <= m; i++)
			sum += 1 / (double) i / i; 
		printf("Case %d: %.5lf\n", count, sum);
	}
	return 0;	
}



习题2-5 分数化小数（ decimal）
输入正整数a， b， c， 输出a/b的小数形式， 精确到小数点后c位。 a， b≤106， c≤100。 输
入包含多组数据， 结束标记为a＝ b＝ c＝ 0。 

# include <iostream>
using namespace std;
 
int main(){
	int a, b, c, count = 0;
	while(cin >> a >> b >> c){
		count++;
		if(a == 0 && b == 0 && c == 0)
			return 0;
		else
			printf("Case: %d: %.*lf\n", count++, c, (double) a / b);
	}
	return 0;
 
}



习题2-6 排列（ permutation）
用1， 2， 3， …， 9组成3个三位数abc， def和ghi， 每个数字恰好使用一次， 要
求abc： def： ghi＝ 1： 2： 3。 按照“abc def ghi”的格式输出所有解， 每行一个解。 提示： 不必太动脑筋。

// 个人感觉这个还不是最简单（C语言）的方法， 可以使用C++STL更方便
 
# include <iostream>
using namespace std;
 
void Judge(int array[], int num){
	int a = num % 10, b = num / 10 % 10, c = num / 100;
	array[a]++; array[b]++; array[c]++;
}
 
int main(){
	for(int i = 100; i < 334; i++){
		int a[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
		int abc = i * 1, def = i * 2, ghi = i * 3, j;
		Judge(a, abc); Judge(a, def); Judge(a, ghi);
		for(j = 1; j < 10; j++){
			if(a[j] != 1 || a[0] != 0)
				break;
		}
		if(j == 10){
			cout << abc << ' ' << def << ' ' << ghi << endl;
		}
	}
}



课后思考题2。 下面的程序运行结果是什么？ “！ ＝ ”运算符表示“不相等”。 提示： 请上机实
验， 不要凭主观感觉回答。

#include<stdio.h>
int main()
{
double i;
for(i = 0; i != 10; i += 0.1)
printf("%.1f\n", i);
return 0;
} 
 
// 死循环， 因为 double 是不能直接用 != 或者 == 的，用误差判别
 
例：const double EFS = 0.000001; for(int i = 0;  i - 10.0 < EFS;  i++);
 

第三章

3-12 处的例子（很有意思，个人推荐试一下）

//输出流的问题

# include <iostream>
using namespace std;
 
int main(){
	int count  = 1;
	count = count++;
	cout << count << endl; 
	cout << count++ << ',' << count++ << ',' << count++ << endl;
} 

习题3-1 得分（ Score, ACM/ICPC Seoul 2005, UVa1585）
给出一个由O和X组成的串（ 长度为1～ 80） ， 统计得分。 每个O的得分为目前连续出现

的O的个数， X的得分为0。 例如， OOXXOXXOOO的得分为1+2+0+0+1+0+0+1+2+3。

# include <iostream>
using namespace std;
 
int main(){
	char s[100001], ch = 1;
	int n = 0;
	scanf("%d", &n);
	while(n--){
		int flag = 0, i = 0, score = 0;
		scanf("%s", s);
		while(s[i] != '\0'){
			if(s[i++] == 'O') score += ++flag;
		else flag = 0;
		}
		cout << score << endl;
	}
	return 0;
}


习题3-2 分子量（ Molar Mass, ACM/ICPC Seoul 2007, UVa1586）
给出一种物质的分子式（ 不带括号） ， 求分子量。 本题中的分子式只包含

给出一种物质的分子式（ 不带括号） ， 求分子量。 本题中的分子式只包含4种原子， 分
别为C, H, O, N， 原子量分别为12.01, 1.008, 16.00, 14.01（ 单位： g/mol） 。 例如， C6H5OH的
分子量为94.108g/mol。

# include <iostream>
# include <cstring>
using namespace std;
 
int main(){
	const double C = 12.01, H = 1.008, O = 16.00, N = 14.01;
	int n; 
	scanf("%d", &n);
	while(n--){
		double sum_w = 0;
		char s[10000];
		scanf("%s", s);
		for(int i = 0; i < strlen(s); ){
			int num = 0, j = i + 1, k = i;
			if(s[j] - '0' < 9 && s[j] != '\0'){
				num = s[j] - '0', j++;
				for( ; s[j] - '0' < 9 && s[j] != '\0'; j++)
					num = num * 10 + (s[j] - '0');
				i = j;
			}
			else num = 1, i++;
			switch (s[k]){
				case 'C': sum_w += 12.01 * num; break;
				case 'H': sum_w += 1.008 * num; break;
				case 'O': sum_w += 16.00 * num; break;
				case 'N': sum_w += 14.01 * num; break; 
			}
		}
		printf("%.3lf\n", sum_w);
	}
	return 0;
}

习题3-3 数数字（ Digit Counting , ACM/ICPC Danang 2007, UVa1225）
把前n（ n≤10000） 个整数顺次写在一起： 123456789101112…数一数0～ 9各出现多少次
（ 输出10个整数， 分别是0， 1， …， 9出现的次数） 。

# include <iostream>
# include <cstring>
using namespace std;
 
int main(){
	int n, a; 
	cin >> n;
	while(n--){
		int s[10];
		memset(s, 0, sizeof(s));
		cin >> a;
		for(int i = 1; i <= a; i++){
			int j = 0, k = i;
			while(1){
				int a1 = k % 10;
				s[a1]++, k /= 10;
				if(k / 10 == 0 && k % 10 == 0)
					break;
			}
		}
		for(int i = 0; i < 9; i++)
			cout << s[i] << ' ';
		cout << s[9] << endl;
	}
	return 0;
}

习题3-4 周期串（ Periodic Strings, UVa455）
如果一个字符串可以由某个长度为k的字符串重复多次得到， 则称该串以k为周期。 例
如， abcabcabcabc以3为周期（ 注意， 它也以6和12为周期） 。
输入一个长度不超过80的字符串， 输出其最小周期。

[cpp] view plain copy
<code class="language-cpp"># include <iostream>  
# include <cstring>  
using namespace std;  
  
int main(){  
    int n;  
    scanf("%d", &n);  
    while(n--){  
        char s[100];  
        scanf("%s", s);  
        int flag = 0;  
        for(int min_len = 1; min_len <= strlen(s); min_len++){  
            if(strlen(s) % min_len != 0) continue;  
            for(int i = 0; i < strlen(s); i++){  
                if(s[i % min_len] != s[i])  
                    break;  
                else if(i == strlen(s) - 1){  
                    flag = 1;  
                    if(n) cout << min_len << endl << endl;  
                    else cout << min_len << endl;  
                }  
            }  
            if(flag) break;  
        }  
    }   
    return 0;  
}</code>  


习题3-5 谜题（ Puzzle, ACM/ICPC World Finals 1993, UVa227）
有一个5*5的网格， 其中恰好有一个格子是空的， 其他格子各有一个字母。 一共有4种指
令： A, B, L, R， 分别表示把空格上、 下、 左、 右的相邻字母移到空格中。 输入初始网格和指
令序列（ 以数字0结束） ， 输出指令执行完毕后的网格。 如果有非法指令， 应输出“This

puzzle has no final configuration.”， 例如， 图3-5中执行ARRBBL0后， 效果如图3-6所示

# include <iostream>
# include <cstring>
using namespace std;
 
int main(){
//	freopen("C:\\1.txt", "r", stdin);
	int n = 1, c = 0;   
	while(n++){
		int flag = 0;// flag 进行输出判断 
		char s[10][10], s1[100];
		int x = 0, y = 0, index_x, index_y;   // 空格的坐标 
		for(int i = 0; i < 5; i++){    
			fgets(s[i], 100, stdin);
			if(s[0][0] == 'Z')  return 0;
		} 
		for(int i = 0; i < 5; i++)   // 找空格位置 
			for(int j = 0; j < 5; j++){
				if(s[i][j] < 'A' || s[i][j] > 'Z'){
					x = i, y = j;
					index_x = x, index_y = y;
					break;
				}
			}
		int j = 0;
		while((s1[j++] = getchar()) != '0'){}   // 读取移动指令 
		getchar();  j = 0;    // 这个getchar() 一定要有，坑了我好久！！！ 
		while(s1[j++] != '0'){   // 执行移动指令
			switch(s1[j-1]){
				case 'A':
					index_x--; break;
				case 'B':
					index_x++; break;
				case 'L':
					index_y--; break;
				case 'R':
					index_y++; break;
			}
			if(index_x < 0 || index_x > 4 || index_y < 0 || index_y > 4){
				flag = 1; break;
			}
			else{
				s[x][y] = s[index_x][index_y];
				s[index_x][index_y] = ' ';
				x = index_x, y = index_y;
			}
		}
		if(c++) cout << endl;
		cout << "Puzzle #" << n - 1 << ':' << endl;
		if(flag) {
			cout << "This puzzle has no final configuration." << endl;
			continue; 
		}
		for(int i = 0; i < 5; i++){
			for(int j = 0; j < 5; j++){
				if(j) cout << ' ';
				cout << s[i][j];
			}
			cout << endl;
		}
	}
	return 0;
}




习题3-6 纵横字谜的答案（ Crossword Answers, ACM/ICPC World Finals 1994,
UVa232）
输入一个r行c列（ 1≤r， c≤10） 的网格， 黑格用“*”表示， 每个白格都填有一个字母。 如
果一个白格的左边相邻位置或者上边相邻位置没有白格（ 可能是黑格， 也可能出了网格边
界） ， 则称这个白格是一个起始格。
首先把所有起始格按照从上到下、 从左到右的顺序编号为1, 2, 3,…， 如图3-7所示 

# include <iostream>
# include <cstring>
using namespace std;
 
int main(){
//	freopen("C:\\1.txt", "r", stdin);
	int n = 1, null = 0;
	while(n++){
		int row, col, count = 0, flag[100][100];
		char s[100][100];
		memset(flag, 0, sizeof(flag));
		cin >> row; 
		if(!row) break;
		cin >> col; getchar();
		for(int i = 0; i < row; i++)  // 输入矩阵 
			fgets(s[i], 100, stdin); 
		for(int i = 0; i < row; i++){  // 标记起始数 并将非 * 数置为 max 
			for(int j = 0; j < col; j++){
				if((s[i][j] != '*') && (i - 1 < 0 || j - 1 < 0 || s[i-1][j] == '*' || s[i][j-1] == '*')){
					flag[i][j] = ++count;
					null++;
				}
				else if(s[i][j] != '*') flag[i][j] = 99999;
			}
		} 
		if(!null) {
			cout << "puzzle #" << n-1 << ':' << endl << "Across" << endl << "Down" << endl;
			continue;
		}
		if(n > 2) cout << endl;
		cout << "puzzle #" << n-1 << ':' << endl << "Across";
		for(int i = 0; i < row; i++){  // Across
			for(int j = 0; j < col; j++){
				if((!flag[i][j-1] && flag[i][j]) || (j - 1 < 0 && flag[i][j]))
					printf("\n%3d.", flag[i][j]);
				if(flag[i][j])  cout << s[i][j];
			}
		}
		cout << endl << "Down";
		for(int fr = 0; fr < row; fr++){
			for(int fc = 0; fc < col; fc++){
				if((flag[fr][fc] && flag[fr][fc] < 1000 && !flag[fr-1][fc]) || (fr - 1 < 0) && flag[fr][fc]){
					printf("\n%3d.", flag[fr][fc]);
					for(int i = fr; i < row; i++){
						if(flag[i][fc]) cout << s[i][fc];
						else break;
					}
				}		
			}
		}
		cout << endl; 
	} 
	return 0;
}

习题4-1 象棋（ Xiangqi, ACM/ICPC Fuzhou 2011, UVa1589）
考虑一个象棋残局， 其中红方有n（ 2≤n≤7） 个棋子， 黑方只有一个将。 红方除了有一个
帅（ G） 之外还有3种可能的棋子： 车（ R） ， 马（ H） ， 炮（ C） ， 并且需要考虑“蹩马
腿”（ 如图4-4所示） 与将和帅不能照面（ 将、 帅如果同在一条直线上， 中间又不隔着任何棋
子的情况下， 走子的一方获胜） 的规则。
输入所有棋子的位置， 保证局面合法并且红方已经将军。 你的任务是判断红方是否已经
把黑方将死。 关于中国象棋的相关规则请参见原题。

# include <iostream>
# include <cstring>
# include <cmath>
using namespace std;
 
struct pst{
	char ch;
	int x;
	int y;
}; 
 
bool is_alive(int flag[][11], int x, int y){   // 只有 0 才可以走 
	for(int i = 1; i < 4; i++){
		for(int j = 4; j < 7; j++){   // 这样的好处是可以避免 越界 
			if(abs(x - i) == 1 && y == j && !flag[i][j])    // 短路求值 
				return false;
			else if(abs(y - j) == 1 && x == i && !flag[i][j])   // 短路求值 
				return false;
		}
	}
	return true;
}
 
void Gernal(int flag[][11], int x, int y){      // 红将军 可以打得范围 
//	cout << "GGGG" << endl;
	for(int i = x-1; i > 0; i--){
		if(flag[i][y] == 999)
			break;
		else{
			flag[i][y] = 1;
//			cout << i << endl;
		}		
	}
}
 
void Chariot(int flag[][11], int x, int y){		// 可以打得范围 
//	cout << "RRRRRRRR" << endl;
	for(int i = 0; i < 11; i++){
		if(flag[i][y] == 999) break;
		else flag[i][y] = 1;
//		cout << i << endl;
		if(i == x - 1) i++;
	}
	for(int j = 0; j < 11; j++){
		if(flag[x][j] == 999) break;
		else flag[j][y] = 1;
//		cout << j << endl;
		if(j == y - 1) j++;
	}
}
 
void Cannon(int flag[][11], int x, int y){		// 炮可以打得范围 
//	cout << "CCCCCCC" << endl; 
	for(int i = x+1; i < 11; i++){
		if(flag[i][y] == 999 && i != 10){
			for(int k = i+1; k < 11 && flag[k][y] != 999; k++){
				flag[k][y] = 1;
//				cout << k << endl; 
			}
			break;
		}
	}
//	cout << endl;
	for(int i = x-1; i > 0; i--){
		if(flag[i][y] == 999 && i != 1){
			for(int k = i-1; k > 0 && flag[k][y] != 999; k--){
				flag[k][y] = 1;
//				cout << k << endl; 
			}
		}
	}
//	cout << endl;
	for(int j = y+1; j < 11; j++){
		if(flag[x][j] == 999 && j != 10){
			for(int k = j+1; k < 11 && flag[x][k] != 999; k++){
				flag[x][k] = 1;
//				cout << k << endl; 
			}
			break;
		}
	}
//	cout << endl;
	for(int j = y-1; j > 0; j--){
		if(flag[x][j] == 999 && j != 1){
			for(int k = j-1; k > 0 || flag[x][k] != 999; k--){
				flag[x][k] = 1;
//				cout << k << endl; 
			}
		}
	}
//	cout << endl;
}
 
void Horse(int flag[][11], int x, int y){		// 马可以打的范围 
//	cout << "HHHHHH" << endl; 
	if(flag[x + 1][y] != 999){
		flag[x + 2][y + 1] = 1;
		flag[x + 2][y - 1] = 1;
	}
	if(flag[x - 1][y] != 999){
		flag[x - 2][y + 1] = 1;
		flag[x - 2][y - 1] = 1; 
	} 
	if(flag[x][y + 1] != 999){
		flag[x + 1][y + 2] = 1;
		flag[x - 1][y + 2] = 1;
	}
	if(flag[x][y - 1] != 999){
		flag[x + 1][y - 2] = 1;
		flag[x - 1][y - 2] = 1;
	}
}
 
 
int main(){
	freopen("C:\\1.txt", "r", stdin);
	int N, bg_x, bg_y, flag[11][11];
	memset(flag, 0, sizeof(flag));
	pst red[100];
	while(1){
		cin >> N >> bg_x >> bg_y;
		if(!N) break;
		for(int i = 0; i < N; i++){    // 输入，并标记 棋子 为max 
			cin >> red[i].ch >> red[i].x >> red[i].y;
		//	cout << red[i].ch << red[i].x << red[i].y << endl;
			flag[red[i].x][red[i].y] = 999;
		}
		for(int i = 0; i < N; i++){   // 逐个压缩黑方将军空间 可以打得地方标记为 1 
			switch(red[i].ch){
				case 'G':
					Gernal(flag, red[i].x, red[i].y);
					break;
				case 'R':
					Chariot(flag, red[i].x, red[i].y);
					break;
				case 'C':
					Cannon(flag, red[i].x, red[i].y);
					break;
				case 'H':
					Horse(flag, red[i].x, red[i].y);
					break;
			}
		}
		if(is_alive(flag, bg_x, bg_y))
			cout << "Yes" << endl;
		else
			cout << "No" << endl;
		}	
	return 0;


算法竞赛入门经典(第二版)-刘汝佳-第三章 数组与字符串 例题+习题（17/18）
说明

本文是我对第三章题目的练习总结，建议配合紫书――《算法竞赛入门经典（第2版）》阅读本文。 
另外为了方便做题，我在VOJ上开了一个contest，欢迎一起在上面做：第三章contest 
如果想直接看某道题，请点开目录后点开相应的题目！！！

例题

例3-1 UVA 272 TeX 中的引号

思路 
这个题主要讲带空格的输入输出处理。我总结了一下，主要有三种方案： 
1、用getchar()一个一个字符处理 
2、用fgets读入（gets已经过时） 
3、用getline读入 
代码

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

int main(void)
{
    char c;
    bool flag = true;
    while ((c = getchar()) != EOF) {
        if (c == '\"') {
            printf("%s", flag ? "``" : "''");
            flag = !flag;
        } else
            printf("%c", c);
    }

    return 0;
}

例3-2 UVA 10082 WERTYU

思路 
常量数组的妙用，可以使程序简洁很多。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

char s[] = "`1234567890-=QWERTYUIOP[]\\ASDFGHJKL;'ZXCVBNM,./";

int main(void)
{
    char c;
    while ((c = getchar()) != EOF) {
        char *p = strchr(s, c);
        if (!p) putchar(c);
        else putchar(s[p-s-1]);
    }

    return 0;
}

例3-3 UVA 401 回文词

思路 
常量字符串和字符串数组的妙用，使程序更简洁。 
另外，学习了strchr函数，主要功能是在字符串中查找字符，返回字符指针。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const char mirror[] = "A   3  HIL JM O   2TUVWXY51SE Z  8 ";
const char *msg[4] = {" -- is not a palindrome.",
    " -- is a regular palindrome.",
    " -- is a mirrored string.",
    " -- is a mirrored palindrome."};

char trans(char c)
{
    if (c <= '9') return mirror[c - '0' + 25];
    return mirror[c - 'A'];
}

int main(void)
{
    char s[30];
    while (cin >> s) {
        int p = 1, m = 1;
        int n = strlen(s);
        for (int i = 0; i <= n/2; i ++) {
            if (s[i] != s[n-1-i]) p = 0;
            if (trans(s[i]) != s[n-1-i]) m = 0;
        }
        printf("%s%s\n\n", s, msg[m*2+p]);
    }

    return 0;
}

例3-4 UVA 340 猜数字游戏的提示

思路 
当数值范围较小时，可以用统计数组。我这里判断正确值和错误值的方式与例题稍有不同，思路大同小异。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1000;
const int M = 10;

int n, a0[N], c0[M], c2[M];
int a1[N], c1[M];

int main(void)
{
    int t = 0;
    while (cin >> n && n) {
        memset(c0, 0, sizeof(c0));
        for (int i = 0; i < n; i ++) {
            scanf("%d", &a0[i]);
            c0[a0[i]]++;
        }

        printf("Game %d:\n", ++t);
        while (true) {
            int flag = false;
            int cntA = 0, cntB = 0;
            memcpy(c2, c0, sizeof(c0));
            memset(c1, 0, sizeof(c1));
            for (int i = 0; i < n; i ++) {
                scanf("%d", &a1[i]);
                if (a1[i]) flag = true;
                c1[a1[i]]++;
                if (a1[i] == a0[i]) {
                    cntA ++;
                    c2[a0[i]] --;
                    c1[a0[i]] --;
                }
            }
            if (flag == false)
                break;
            for (int i = 1; i < M; i ++)
                if (c2[i]) cntB += min(c1[i], c2[i]);
            printf("    (%d,%d)\n", cntA, cntB);
        }
    }

    return 0;

例3-5 UVA 1583 生成元

思路 
当计算过程复杂而且对结果有多次查询时，就应当考虑将计算结果保存成表，从而大大提高查询效率。 
这是本题的主要思想。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 100000;

int main(void)
{
    int n, a[N+1];
    memset(a, 0, sizeof(a));
    for (int i = 1; i < N; i ++) {
        int m = i, sum = 0;
        while (m) { sum += m%10; m /= 10;}
        n = sum + i;
        if (n <= N && a[n] == 0) a[n] = i;
    }

    int t;
    cin >> t;
    while (t--) {
        cin >> n;
        printf("%d\n", a[n]);
    }

    return 0;


例3-6 UVA 1584 环状序列

思路 
此题考查字符串排序。我的做法与书中不同，我是将长度为n字符串s复制一份连接到它的后面成为s2，这样环状序列的所有表示就是s2中所有长度为n的子字符串，用strncmp比较即可。 
书中做法和我的方法都避免了n次字符串复制操作。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 100;

int main(void)
{
    int t, n;
    char s0[2*N+1], s1[2*N+1];

    cin >> t;
    while (cin >> s0) {
        n = strlen(s0);
        strcpy(s1, s0);
        strcat(s0, s1);
        strcpy(s1, s0);
        int mi = 0;
        for (int i = 0; i < n; i ++) {
            if (strncmp(s0+mi, s1+i, n) > 0)
                mi = i;
        }
        strncpy(s1, s0+mi, n);
        s1[n] = '\0';
        printf("%s\n", s1);
    }

    return 0;
}
1
习题

习3-1 UVA 1585 得分

思路 
用add变量记录当前的O字符连续出现的个数，遇到X清零。 
代码

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

int main(void)
{
    int t;
    char s[81];

    cin >> t;
    while (t--) {
        scanf("%s", s);
        int add = 0, sum = 0;
        for (int i = 0; s[i]; i ++) {
            if (s[i] == 'O') {
                add ++;
                sum += add;
            } else
                add = 0;
        }
        printf("%d\n", sum);
    }

    return 0;
}

习3-2 UVA 1586 分子量

思路 
考察基本的输入分析，可以先读入整个字符串然后分析。 
代码

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const char name[] = "CHON";
double weight[] = {12.01, 1.008, 16.00, 14.01};

int main(void)
{
    int t;
    char s[81];

    cin >> t;
    while (t--) {
        scanf("%s", s);
        int num;
        double sum = 0;
        int i = 0;
        while (s[i]) {
            int j;
            for (j = 0; j < 4; j ++) {
                if (s[i] == name[j]) break;
            }
            i ++;
            num = 1;
            if (isdigit(s[i])) num = (s[i++]-'0');
            if (isdigit(s[i])) num = num*10 + (s[i++]-'0');
            sum += num * weight[j];
        }
        printf("%.3lf\n", sum);
    }

    return 0;
}

习3-3 UVA 1225 数数字

思路 
这个题暴力搜索也能过，因为数据范围太小。但这样就失去了意义。 
我用函数写的，具有较强的普适性。主要思想是对每一位分别分析――当前位、高位、低位分别为指定数字――情况下的数的个数。 
代码

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

int cnt(int n, int x)
{
    int res = 0;
    int fact = 1, high = n/10, crt = n%10, low = 0;
    while (high || (x && crt >= x)) {
        //printf("%d %d %d %d\n", fact, high, crt, low);
        res += high*fact;
        if (x == 0) res -= fact;
        if (crt > x) res += fact;
        if (crt == x) res += (low+1);
        low += fact*crt;
        crt = high%10;
        high /= 10;
        fact *= 10;
    }
    return res;
}


int main(void)
{
    int t, n;
    cin >> t;
    while (t --) {
        cin >> n;
        for (int i = 0; i < 10; i ++) {
            printf("%d%c", cnt(n, i), i == 9 ? '\n' : ' ');
        }
    }

    return 0;
}

习3-4 UVA 455 周期串

思路 
字符串的周期一定是长度的约数，根据这个进行枚举就可以了。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;

int main(void)
{
    int t;
    char s[81];

    cin >> t;
    while (t --) {
        scanf("%s", s);
        int i;
        int n = strlen(s);
        for (i = 1; i <= n; i ++) {
            if (n % i) continue;
            bool flag = true;
            for (int j = 1; j < n/i; j ++) {
                for (int k = 0; k < i; k ++) {
                    if (s[k] != s[k+j*i]) {
                        flag = false; break;
                    }
                }
                if (flag == false) break;
            }
            if (flag == true) break;
        }
        printf("%d\n", i);
        if (t) printf("\n");
    }

    return 0;

习3-5 UVA 227 谜题

思路 
这个题我用了两个常量数组，inst数组的作用是将字符翻译成方向数组对应的下标（0-3），方向数组dir的作用是表示四个方向x和y坐标的变化。这样一个循环就ok了，不需要4个方向重复写4次代码。 
另外注意最后一组数据后面没有空行，UVA很多题目都要求这样输出。 
代码

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const char inst[] = "ABLR";
const int dir[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

int main(void)
{
    int t = 0;
    char s[5][6];
    char c;
    while ((s[0][0] = getchar()) != 'Z') {
        int bi = 0, bj = 0;
        for (int i = 0; i < 5; i ++) {
            for (int j = 0; j < 5; j ++) {
                if (!i && !j) continue;
                s[i][j] = getchar();
                if (s[i][j] == ' ') {bi = i, bj = j;}
            }
            getchar();
        }
        bool legal = true;
        while ((c = getchar()) != '0') {
            if (legal == false || c == '\n') continue;
            int k;
            for (k = 0; k < 4; k ++) {
                if (c == inst[k]) break;
            }
            if (k == 4)
                legal = false;
            else {
                int ni = bi+dir[k][0], nj = bj+dir[k][1];
                if (0 <= ni && ni < 5 && 0 <= nj && nj < 5) {
                    swap(s[bi][bj], s[ni][nj]);
                    bi = ni, bj = nj;
                } else
                    legal = false;
            }
        }
        if (++t > 1) printf("\n");
        printf("Puzzle #%d:\n", t);
        if (legal == false)
            printf("This puzzle has no final configuration.\n");
        else {
            for (int i = 0; i < 5; i ++) {
                for (int j = 0; j < 5; j ++) {
                    printf("%c%c", s[i][j], j == 4 ? '\n' : ' ');
                }
            }
        }
        getchar();
    }

    return 0;
}
习3-6 UVA 232 纵横字谜的答案

思路 
因为需要编号，应当先扫描并保存起始格的位置，然后分别输出横向和纵向的单词。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 10;

int main(void)
{
    int t = 0;
    int n, m;
    char s[N][N+1];
    int cnt = 0;
    int pos[N*N+1][2];
    while (scanf("%d", &n) != EOF && n) {
        scanf("%d", &m);
        getchar();
        cnt = 0;
        memset(pos, 0, sizeof(pos));
        for (int i = 0; i < n; i ++) {
            for (int j = 0; j < m; j ++) {
                s[i][j] = getchar();
                if (s[i][j] == '*') continue;
                if (i == 0 || j == 0 || s[i-1][j] == '*' || s[i][j-1] == '*') {
                    pos[cnt][0] = i, pos[cnt][1] = j;
                    cnt ++;
                }
            }
            getchar();
        }

        if (t > 0) printf("\n");
        printf("puzzle #%d:\n", ++t);
        printf("Across\n");
        for (int k = 0; k < cnt; k ++) {
            int i = pos[k][0], j = pos[k][1];
            if (j > 0 && s[i][j-1] != '*') continue;
            printf("%3d.", k+1);
            do {
                printf("%c", s[i][j]);
                j ++;
            } while (j < m && s[i][j] != '*');
            printf("\n");
        }
        printf("Down\n");
        for (int k = 0; k < cnt; k ++) {
            int i = pos[k][0], j = pos[k][1];
            if (i > 0 && s[i-1][j] != '*') continue;
            printf("%3d.", k+1);
            do {
                printf("%c", s[i][j]);
                i ++;
            } while (i < n && s[i][j] != '*');
            printf("\n");
        }
    }

    return 0;
}

习3-7 UVA 1368 DNA 序列

思路 
找出每列中ACGT出现次数最多的字符，就是最优解序列在这一列的字符值。另外注意要求的是字典序最小的解。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 1000;
const int M = 50;
char *DNA = "ACGT";

int main(void)
{
    int m, n;
    char s[M][N+1];
    int cnt[N][4];
    int ans[N];
    int d;

    int t;
    cin >> t;
    while (t --) {
        cin >> m >> n;
        for (int i = 0; i < m; i ++)
            scanf("%s", s[i]);

        memset(cnt, 0, sizeof(cnt));
        for (int i = 0; i < m; i ++) {
            for (int j = 0; j < n; j ++) {
                cnt[j][strchr(DNA, s[i][j]) - DNA] ++;
            }
        }
        memset(ans, 0, sizeof(ans));
        d = 0;
        for (int j = 0; j < n; j ++) {
            for (int k = 0; k < 4; k ++) {
                if (cnt[j][k] > cnt[j][ans[j]])
                    ans[j] = k;
            }
            for (int k = 0; k < 4; k ++)
                if (k != ans[j]) d += cnt[j][k];
        }

        for (int j = 0; j < n; j ++)
            putchar(DNA[ans[j]]);
        printf("\n%d\n", d);
    }

    return 0;
}
习3-8 UVA 202 循环小数

思路 
求循环节需要模拟循环小数的求解过程。那么什么时候会出现循环呢？在除的过程中，除数b是不变的，而被除数a一直在变化，那么当a变换为之前出现过的某个值时，就出现了循环。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

const int N = 3000;

int main(void)
{
    int a, b;
    while (scanf("%d%d", &a, &b) != EOF) {
        printf("%d/%d = %d.", a, b, a/b);
        a %= b;
        int n = 0;;
        int dec[N+1];
        int arr[N+1];
        bool used[N+1] = {0};
        while (!used[a]) {
            arr[n] = a;
            used[a] = 1;
            a *= 10;
            dec[n] = a/b;
            n++;
            a %= b;
        }
        int m = 0;
        for (m = 0; m < n; m++) {
            if (arr[m] == a) break;
        }

        for (int i = 0; i < m; i++)
            printf("%d", dec[i]);
        printf("(");
        for (int i = m; i < n && i < m+50; i++)
            printf("%d", dec[i]);
        int len = n - m;
        if (len > 50) printf("...");
        printf(")\n   %d = number of digits in repeating cycle\n\n", len);
    }

    return 0;
}

习3-9 UVA 10340 子序列

思路 
顺序扫描t中字符，遇到与s首字符相同情况即删除s首字符，同时继续往前扫描。当s中字符空时，说明t删除字符可以得到s。 
代码

#include <iostream>
#include <cstdio>
#include <string>
#include <algorithm>
using namespace std;

int main(void)
{
    string s1, s2;
    while (cin >> s1 >> s2) {
        int i = 0;
        for (int j = 0; j < s2.size(); j ++) {
            if (s1[i] == s2[j]) i++;
            if (i == s1.size()) break;
        }
        printf("%s\n", i == s1.size() ? "Yes" : "No");
    }

    return 0;
}

习3-10 UVA 1587 盒子

思路 
这种题目看似简单，但不好写标准统一的代码，而且容易漏掉一些细节而出错。我建议尽量将代码标准化，减少失误的可能。有同学用类的思想处理，有值得借鉴之处。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int main(void)
{
    int a[12];
    while (scanf("%d%d", &a[0], &a[1]) != EOF) {
        if (a[0] > a[1]) swap(a[0], a[1]);
        for (int i = 2; i < 12; i += 2) {
            scanf("%d%d", &a[i], &a[i+1]);
            if (a[i] > a[i+1]) swap(a[i], a[i+1]);
        }
        int b[12];
        memcpy(b, a, sizeof(a));
        sort(a, a+12);

        bool flag = true;
        int n[3];
        for (int i = 0; i < 3; i ++) {
            n[i] = a[i*4];
            for (int j = 1; j < 4; j ++) {
                if (n[i] != a[i*4+j])
                    flag = false;
            }
        }

        int m[3] = {0};
        for (int i = 0; i < 12; i += 2) {
            if (m[0] < 2 && b[i] == n[0] && b[i+1] == n[1]) m[0] ++;
            else if (m[1] < 2 && b[i] == n[0] && b[i+1] == n[2]) m[1] ++;
            else if (m[2] < 2 && b[i] == n[1] && b[i+1] == n[2]) m[2] ++;
            else flag = false;
        }
        if (! (m[0] == 2 && m[1] == 2) )
            flag = false;
        //printf("%d %d %d\n", m[0], m[1], m[2]);

        if (flag)
            printf("POSSIBLE\n");
        else
            printf("IMPOSSIBLE\n");
    }

    return 0;
}习3-11 UVA 1588 换低档装置

思路 
此题同上题一样，在标准化方面有一定困难。我一开始写的程序能通过用例，但死活就一直WA。 
这段代码是参考别人的写的，其代码比较规范，值得推荐。 
代码

#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

char s1[110], s2[110];

int test(int k, char s1[], char s2[]) {
    for (int i = 0; s1[k+i] && s2[i]; i++)
      if (s1[k+i]+s2[i]-2*'0' > 3) return 0;
    return 1;
}

int fun(char s1[], char s2[]) {
    int k = 0;
    while (!test(k, s1, s2)) k++;
    return max(strlen(s1), strlen(s2)+k);
}

int main() {
    while (scanf("%s%s", s1, s2) != EOF) {
        printf("%d\n", min(fun(s1, s2), fun(s2, s1)));
    }
    return 0;

习3-12 UVA 11809 浮点数

思路 
我的做法是根据最大十进制数反推二进制表示中的M和E，例子都过了，但是提交后TLE。搜了一下其他人的解法，清一色的打表。这个题的M和E范围确实有限，打表只需要预先计算300个并保存，然后查表即可。 
估计这个题的查询量比较大吧，否则我直接求应该也可以的。 
有时间重新写一个打表的程序把这题AC掉，先贴上我的TLE代码。看到本文的大神如有指导也请不吝赐教。 
代码

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<cmath>
using namespace std;

const double EPS = 1e-6;

int main()
{
    double a;
    while (scanf("%lf", &a) != EOF) {
        if (abs(a) < EPS) break;
        int y = 0;
        while (a >= 1) {
            a /= 2;
            y++;
        }

        int m = 0;
        a = 1-a;
        while (abs(a-1) > EPS) {
            a = a*2;
            m ++;
        }

        int e = 0;
        while (y) {
            e++;
            y /= 2;
        }

        printf("%d %d\n", m-1, e);
    }

    return 0;

}
}  说明

本文是我对第四章题目的练习总结，建议配合紫书――《算法竞赛入门经典（第2版）》阅读本文。 
另外为了方便做题，我在VOJ上开了一个contest，欢迎一起在上面做：第四章contest 
如果想直接看某道题，请点开目录后点开相应的题目！！！

例题

例4-1 UVA 1339 古老的密码

思路 
只需要分别统计两个字符串中26个字母出现的个数，然后对统计数组做一个排序，如果一样则结果为YES。 
详细解释见书P73。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int main(void)
{
    int n[2], cnt[2][26];
    char s[2][101];
    while (cin >> s[0] >> s[1]) {
        memset(cnt, 0, sizeof(cnt));
        for (int i = 0; i < 2; i ++) {
            n[i] = strlen(s[i]);
            for (int j = 0; j < n[i]; j ++)
                cnt[i][s[i][j]-'A'] ++;
            sort(cnt[i], cnt[i]+26);
        }

        bool flag = true;
        for (int j = 0; j < 26; j ++)
            if (cnt[0][j] != cnt[1][j]) flag = false;
        printf("%s\n", flag ? "YES" : "NO");
    }

    return 0;
}例4-2 UVA 489 刽子手游戏

思路 
给定两个字符串，第一个串是用来匹配的，从第二个串的第一个字符开始匹配，如果第二个串中的字符在第一个串出现，则表示猜中了，第一个串中的相同的那个字符都算被猜中；如果没有出现则表示猜错，同样的猜错只算一次。在整个匹配的过程中，如果在还没猜错7次之前，第一个串中所有的字符都被猜完了， 则输出“You win.”，如果你还没全部猜完的时候就已经猜错7次，则输出“You lose.”。如果整个匹配过程结束后，你没赢也没输，则输出“You chickened out.”。 
这个题需要注意的细节很多，我WA了多次。在这里提供一组测试数据吧，希望对一直WA的同学有用。 
测试数据来源：uva489讨论

INPUT： 
1 
cheese 
chese 
2 
cheese 
abcdefg 
3 
cheese 
abcdefgij 
4 
rommel 
romlnptuyq 
5 
rommel 
romlnptuyqw 
6 
casa 
ca 
7 
otorrinolaringologia 
otr 
8 
peru 
abcdefghijklmno 
9 
lastima 
la 
10 
aaaaaaaaaaaaaaaaaaaaaa 
a 
11 
bobobobobobobo 
b 
12 
lalalalabababababaaaaa 
alhhhhhhhhhhhhhhhhhhhhhhh 
13 
lkjaskljfkjklsalsdjfslkjfjf 
dfklsdfskld 
14 
nbmbmmbnbbmbmbmbmnbnbnbmbmmbbnbnnbmbmbmboffiifififififfiif 
ppppppppppppppppppppppppppppppppppwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwweeeeeeeeeeeeeeeeeeeeeeeeeeeeeerrrrrrrrrrrrrrrrrrrrrrrrrrrrb 
15 
abcdefggegegegegegege 
gegegegegddabacecevbbdbdnndnenjejje 
16 
diccionariosdeportugues 
dcptgiowqqqaazzxxxx 
17 
b 
c 
18 
kljfdsjfoieoijefnvnenvionewveinvewv 
dkdjjshue 
19 
ooooooooooooopppppppppppppppppppppeeeeeeeeeeeeeeeeeeeeeerrrrrrrrrrrrrrrrrrrrrrrrrwwwwwwwwwwwwwwwwwwwtttttttttttttttttt 
operwt 
20 
ooooooooooooopppppppppppppppppppppeeeeeeeeeeeeeeeeeeeeeerrrrrrrrrrrrrrrrrrrrrrrrrwwwwwwwwwwwwwwwwwwwtttttttttttttttttt 
operwqzxcvbnmklo 
21 
ploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploplo 
jslkfsdjfsjfljfsdjfkdsjkjflkf 
22 
a?oa?oa?oa?oa?oa?oa?oa?oa?oa?oa?oa?oa?oa?oa?operuperuperuperuperuperuperuperuperua?oa?oa?oa?oa?oa?oa?oa?oa?oa?o 
a?operu 
23 
a?oa?oa?oa?oa?oa?oa?oa?oa?oa?oa?oa?oa?oa?oa?operuperuperuperuperuperuperuperuperua?oa?oa?oa?oa?oa?oa?oa?oa?oa?o 
ududududuudududupepeppewguqwhuihewhepqwehuwehwmncvmnnvmnvcnb 
4 
t 
r 
1 
aaa 
bcdbcdbcdbcdefghja 
7 
aaa 
bcdbcdbcdbcdefdta 
2 
aaa 
bcdbcdbcdbcdegt 
1 
cheese 
ch 
1 
z 
abcdef 
1 
aaa 
bcdbcdbcdbcdefghja 
7 
aaa 
bcdbcdbcdbcdefdta 
2 
aaa 
bcdbcdbcdbcdegt 
167 
axyq 
eprxibexxyf 
171 
nho 
tonpyzwotkg 
1 
z 
abcdef 
1 
abcdef 
aghijklmcdefb 
2 
abcdef 
abcdklmnoegfi 
3 
abcdef 
abcklmnopdf 
-1

OUTPUT： 
Round 1 
You win. 
Round 2 
You chickened out. 
Round 3 
You lose. 
Round 4 
You chickened out. 
Round 5 
You lose. 
Round 6 
You chickened out. 
Round 7 
You chickened out. 
Round 8 
You lose. 
Round 9 
You chickened out. 
Round 10 
You win. 
Round 11 
You chickened out. 
Round 12 
You chickened out. 
Round 13 
You chickened out. 
Round 14 
You chickened out. 
Round 15 
You chickened out. 
Round 16 
You chickened out. 
Round 17 
You chickened out. 
Round 18 
You chickened out. 
Round 19 
You win. 
Round 20 
You lose. 
Round 21 
You chickened out. 
Round 22 
You win. 
Round 23 
You lose. 
Round 4 
You chickened out. 
Round 1 
You lose. 
Round 7 
You win. 
Round 2 
You chickened out. 
Round 1 
You chickened out. 
Round 1 
You chickened out. 
Round 1 
You lose. 
Round 7 
You win. 
Round 2 
You chickened out. 
Round 167 
You chickened out. 
Round 171 
You lose. 
Round 1 
You chickened out. 
Round 1 
You lose. 
Round 2 
You win. 
Round 3 
You chickened out.

代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int main(void)
{
    int rnd;
    int used[26];
    char s[1000];
    while (cin >> rnd && rnd != -1) {
        memset(used, 0, sizeof(used));
        scanf("%s", s);
        int len = strlen(s);
        for (int i = 0; s[i]; i ++)
            used[s[i]-'a'] ++;

        int wrong = 0;
        scanf("%s", s);
        for (int i = 0; s[i]; i ++) {
            if (used[s[i]-'a']) {
                len -= used[s[i]-'a'];
                used[s[i]-'a'] = 0;
            } else
                wrong ++;
            if (wrong == 7 || len == 0) break; 
        }

        printf("Round %d\n", rnd);
        if (wrong == 7)
            printf("You lose.\n");
        else if (len <= 0)
            printf("You win.\n");
        else
            printf("You chickened out.\n");
    }

    return 0;
}例4-3 UVA 133 发放救济金

思路 
这个题没什么复杂度，就只是模拟。注意go函数可以把顺时针和逆时针统一起来的巧妙方法。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int n, k, m;
int person[20];

int go(int s, int d, int p)
{
    while (d--) {
        do {
            s = (s+p+n) % n;
        } while (!person[s]);
    }
    return s;
}

int main(void)
{
    while (cin >> n >> k >> m, n || k || m) {
        memset(person, 1, sizeof(person));
        int left = n;
        int a = n-1, b = 0;
        while (left) {
            a = go(a, k, 1);
            b = go(b, m, -1);
            if (left < n) printf(",");
            printf("%3d", a+1);
            person[a] = 0;
            left --;
            if (person[b]) {
                printf("%3d", b+1);
                person[b] = 0;
                left --;
            }
            if (left == 0) break;
        }
        printf("\n");
    }

    return 0;
}
例4-4 UVA 213 信息解码

思路 
主要考察两个知识点：getchar()读入，以及二进制与十进制的互相转换。 
同时，频繁使用的或者模块性很强的功能写成函数，的确能使代码精简很多。 
代码

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 7;
const int M = 1<<(N+1);

char head[M];
int bi[N+1];

void init()
{
    bi[1] = 0;
    int fact = 1;
    for (int i = 1; i < 7; i ++) {
        fact <<= 1;
        bi[i+1] = bi[i] + fact - 1;
    }
}

int get01()
{
    char c;
    while ((c = getchar()) == '\n');
    return c-'0';
}

int getMsg(int len)
{
    int res = 0;
    while (len --)
        res = 2*res + get01();
    return res;
}

char decode(int msg, int len)
{
    return head[bi[len]+msg];
}

int main(void)
{
    init();
    while (gets(head)) {
        int len;
        while (len = getMsg(3)) {
            int msg;
            while ((msg = getMsg(len)) != ((1<<len)-1))
                putchar(decode(msg, len));
        }
        putchar('\n');
        getchar();
    }

    return 0;
}例4-5 UVA 512 追踪电子表格中的单元格

思路 
我总觉得书中给出的第一种解法时间复杂度不好。因为每次删除或增加行列，后面所有的行列都要跟着动，这样每个操作的复杂度是O(n^2)。 
我是用链表来做的，将使用的行（列）的id建立一个顺序链表，其它未使用（或删除）的id分别放到行（列）的队列中，如果插入就取出一个id来用。 
但这样导致我写的代码很长，而且确实比较复杂，尽管原题的范例都通过了，但提交后一直WA。目前这是我第四章唯一没有AC的题。等有时间再重新看这个题吧。 
先贴上WA代码。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
#include <vector>
using namespace std;

const int N = 51;

int n, m;
int data[N+1][N+1];
int next[2][N+1];
int pos[N+1][N+1];
priority_queue<int, vector<int>, greater<int> > pq[2];

void init_data()
{
    memset(next, 0, sizeof(next));
    for (int i = 0; i < 2; i++)
        while (pq[i].size()) pq[i].pop();
    memset(data, 0, sizeof(0));
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            data[i][j] = i*N+j;
    for (int i = 1; i <= n; i++)
        next[0][i-1] = i;
    for (int i = n+1; i <= N; i++)
        pq[0].push(i);
    for (int j = 1; j <= m; j++)
        next[1][j-1] = j;
    for (int j = m+1; j <= N; j++)
        pq[1].push(j);
}

int id(int t, int k)
{
    int u = 0;
    while (k--) u = next[t][u];
    return u;
}

void exchange(int ax, int ay, int bx, int by)
{
    swap(data[id(0, ax)][id(1, ay)], data[id(0, bx)][id(1, by)]);
}

void ins_or_del(char op, int t, vector<int> num)
{
    sort(num.begin(), num.end());
    int u = 0, un = next[t][u];
    int k = 0, i = 0;
    while (un) {
        k++;
        if (num[i] == k) {
            if (op == 'D') {
                next[t][u] = next[t][un];
                pq[t].push(un);
                int h = next[1-t][0];
                while (h) {
                    if (t == 0) data[un][h] = 0;
                    else data[h][un] = 0;
                    h = next[1-t][h];
                }
            } else {
                int j = pq[t].top();
                pq[t].pop();
                next[t][u] = j;
                next[t][j] = un;
                u = un;
            }
            i++;
            if (i == num.size()) break;
        } else
            u = next[t][u];
        un = next[t][un];
    }
    int x = (op == 'D') ? -1 : 1;
    if (t == 0) n += x*num.size();
    else m += x*num.size();
}

void print()
{
    printf("==========\n");
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            int x = data[id(0, i)][id(1, j)];
            printf("%d,%d  ", x/N, x%N);
        }
        printf("\n"); 
    }
}   

void prase_pos()
{       
    vector<int> ids[2];
    for (int i = 0; i < 2; i++) {
        int u = next[i][0];
        while (u) { 
            ids[i].push_back(u);
            u = next[i][u];
        }           
    }               

    memset(pos, 0, sizeof(pos));
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            int x = data[ids[0][i-1]][ids[1][j-1]];
            if (x) pos[x/N][x%N] = i*N+j;
        }       
    }       
}           

int main(void)
{           
    int kase = 0;
    int t, k, j;
    char op[3]; 
    int ax, ay, bx, by;
    while (scanf("%d%d", &n, &m), n || m) {
        init_data();
        scanf("%d", &t);
        for (int i = 0; i < t; i++) {
            scanf("%s", op);
            if (op[0] == 'E') {
                scanf("%d%d%d%d", &ax, &ay, &bx, &by);
                exchange(ax, ay, bx, by);
            } else {
                scanf("%d", &k);
                vector<int> num;
                while (k--) {
                    scanf("%d", &j);
                    num.push_back(j);
                }
                int type = (op[1] == 'R') ? 0 : 1;
                ins_or_del(op[0], type, num);
            }
            //print();
        }

        prase_pos();
        scanf("%d", &t);
        if (++kase > 1) printf("\n");
        printf("Spreadsheet #%d\n", kase);
        for (int i = 0; i < t; i++) {
            scanf("%d%d", &ax, &ay);
            printf("Cell data in (%d,%d) ", ax, ay);
            int p = pos[ax][ay];
            if (p) printf("moved to (%d,%d)\n", p/N, p%N);
            else printf("GONE\n");
        }
    }

    return 0;
}例4-6 UVA 12412 师兄帮帮忙

思路 
这个题实在不想ACM题，纯粹模拟，小细节特别多。不过我竟然只WA了一次就过了，很庆幸啊！ 
由于需要频繁的插入删除操作，我采用双向链表作为主要数据结构。这里的链表不是数据结构书中常用的结构体链表，而是数组链表。具体做法就是开一个大结构体数组，用到的节点对应的数组下标插入链表中，未使用的下标放在queue中，插入节点时从queue中取id，删除时将id回收到queue中。这样做的好处是内存少，时间复杂度低。 
打印全部信息的函数可以用循环写的更规范一些，详见代码。 
需要注意的几个细节有： 
1、精度的控制，注意加EPS 
2、人数为0时平均分输出为0 
3、搜索学号只可能有一个，姓名则可能有多个 
代码

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
#include<vector>
using namespace std;

const int N = 100;
const double EPS = 1e-5;

struct Stu {
    char sid[11];
    int cid;
    char name[11];
    int score[4];
    int total;
};

Stu stus[N+1];
int n;
int pre[N+1], next[N+1];
queue<int> ID;

const char *msg[] = {"", "Please enter the SID, CID, name and four scores. Enter 0 to finish.",
"Please enter SID or name. Enter 0 to finish.",
"Please enter SID or name. Enter 0 to finish.",
"Showing the ranklist hurts students' self-esteem. Don't do that.", ""};

void print_menu()
{
    puts("Welcome to Student Performance Management System (SPMS).\n");
    puts("1 - Add");
    puts("2 - Remove");
    puts("3 - Query");
    puts("4 - Show ranking");
    puts("5 - Show Statistics");
    puts("0 - Exit\n");
}

void init()
{
    n = 0;
    memset(pre, 0, sizeof(pre));
    memset(next, 0, sizeof(next));
    for (int i = 1; i <= N; i++)
        ID.push(i);
}

int search_sid(char sid[11])
{
    int u = next[0];
    while (u) {
        if (strcmp(stus[u].sid, sid) == 0) return u;
        u = next[u];
    }
    return 0;
}

void search_name(vector<int>& ids, char name[11])
{
    int u = next[0];
    while (u) {
        if (strcmp(stus[u].name, name) == 0) ids.push_back(u);
        u = next[u];
    }
}

void add()
{
    char sid[11];
    puts(msg[1]);
    while (scanf("%s", sid) && strcmp(sid, "0")) {
        int id = ID.front();
        ID.pop();
        Stu& s = stus[id];
        strcpy(s.sid, sid);
        scanf("%d%s", &s.cid, s.name);
        s.total = 0;
        for (int i = 0; i < 4; i++) {
          scanf("%d", &s.score[i]);
          s.total += s.score[i];
        }
        if (search_sid(sid))
          puts("Duplicated SID.");
        else {
            next[id] = next[0];
            next[0] = id;
            pre[id] = 0;
            pre[next[id]] = id;
            n++;
        }
        puts(msg[1]);
    }
}

void remove()
{
    char s[11];
    puts(msg[2]);
    while (scanf("%s", s) && strcmp(s, "0")) {
        int id;
        vector<int> ids;
        int cnt = 0;
        if (id = search_sid(s)) {
            next[pre[id]] = next[id];
            pre[next[id]] = pre[id];
            ID.push(id);
            cnt = 1;
        } else {
            search_name(ids, s);
            if (cnt = ids.size()) {
                for (int i = 0; i < cnt; i++) {
                    id = ids[i];
                    ID.push(id);
                    next[pre[id]] = next[id];
                    pre[next[id]] = pre[id];
                }
            }
        }
        n -= cnt;
        printf("%d student(s) removed.\n", cnt);
        puts(msg[2]);
    }
}

int get_rank(int score)
{
    int u = next[0];
    int rank = 1;
    while (u) {
        if (stus[u].total > score) rank++;
        u = next[u];
    }
    return rank;
}

void print_stu(int id)
{
    Stu &s = stus[id];
    printf("%d %s %d %s", get_rank(s.total), s.sid, s.cid, s.name);
    for (int i = 0; i < 4; i++)
        printf(" %d", s.score[i]);
    printf(" %d %.2lf\n", s.total, s.total/4.0+EPS);
}

void query()
{
    char s[11];
    puts(msg[3]);
    while (scanf("%s", s) && strcmp(s, "0")) {
        int id;
        vector<int> ids;
        int cnt = 0;
        if (id = search_sid(s)) {
            print_stu(id);
        } else {
            search_name(ids, s);
            if (cnt = ids.size()) {
                for (int i = cnt-1; i >= 0; i--)
                  print_stu(ids[i]);
            }
        }
        puts(msg[3]);
    }
}

void show_rank()
{
    puts(msg[4]);
}

const char *courses[] = {"Chinese", "Mathematics", "English", "Programming"};

void show_stat()
{
    int cid = 0;
    printf("Please enter class ID, 0 for the whole statistics.\n");
    scanf("%d", &cid);

    int num = 0, total[4] = {0}, passed1[4] = {0}, passed2[5] = {0};
    int u = next[0];
    while (u) {
        Stu& s = stus[u];
        if (cid == 0 || s.cid == cid) {
            num++;
            int cnt = 0;
            for (int i = 0; i < 4; i++) {
                total[i] += s.score[i];
                passed1[i] += (s.score[i]/60);
                cnt += (s.score[i]/60);
            }
            passed2[cnt]++;
        }
        u = next[u];
    }
    for (int i = 0; i < 4; i++) {
        puts(courses[i]);
        printf("Average Score: %.2lf\n", num ? (double)(total[i])/num+EPS : 0);
        printf("Number of passed students: %d\n", passed1[i]);
        printf("Number of failed students: %d\n\n", num-passed1[i]);
    }
    puts("Overall:");
    for (int i = 4; i >= 1; i--) {
        if (i == 4) printf("Number of students who passed all subjects: ");
        else {
            printf("Number of students who passed %d or more subjects: ", i);
            passed2[i] += passed2[i+1];
        }
        printf("%d\n", passed2[i]);
    }
    printf("Number of students who failed all subjects: %d\n\n", passed2[0]);
}

int main()
{
    int cmd;
    print_menu();
    init();
    while (scanf("%d", &cmd) && cmd) {
        switch(cmd) {
            case 1:
                add();
                break;
            case 2:
                remove();
                break;
            case 3:
                query();
                break;
            case 4:
                show_rank();
                break;
            case 5:
                show_stat();
                break;
            case 0:
            default:
                return 0;
        }
        print_menu();
    }

    return 0;
}习题

习4-1 UVA 1589 象棋

思路 
我的思路是考察所有黑方的将下一步的位置是否会被红方的子吃掉。检查的时候可以根据棋盘，也可以根据棋子。事实上后一种复杂度应该略低一些，因为红方最多有7个子。 
另外有几个小技巧： 
1、蹩马腿的判断可以用数组实现，详见代码。 
2、棋子车和炮是否将军的判断可以根据棋子与将之间棋子的个数来判断，车与将之间为0,或炮与将之间为1都是将军。 
即使示例能过，这个题也很可能WA。我在这个题上没有注意到的地方有： 
1、黑方的将可能吃掉红方的子。因而需要实现保存上一步的棋盘。

代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

struct Chess {
    char t; //0, 1, G, R, H, C
    int x, y;
    Chess () {}
    Chess (char t1, int x1, int y1)
    {
        t = t1, x = x1, y = y1;
    }
};

char tab0[11][11], tab[11][11];
Chess gnr;
int n;
Chess pos[8];
int mov[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
int movH[8][2] = {{1, 2}, {-1, 2}, {2, 1}, {2, -1},
    {1, -2}, {-1, -2}, {-2, 1}, {-2, -1}};

bool legal(int x, int y)
{
    return 1 <= x && x <= 3 && 4 <= y && y <= 6;
}

Chess move(Chess p, int i)
{
    Chess p1(p.t, p.x+ mov[i][0], p.y + mov[i][1]);
    if (!legal(p1.x, p1.y)) return Chess('0', 1, 1);
    tab[p1.x][p1.y] = '1';
    tab[p.x][p.y] = '0';
    return p1;
}

int cnt(Chess p1, Chess p2)
{
    int cnt = 0;
    if (p1.x == p2.x) {
        int add = (p1.y < p2.y ? 1 : -1);
        for (int j = p1.y+add; j != p2.y; j += add) {
            if (tab[p1.x][j] != '0') cnt ++;
        }
    }
    else if (p1.y == p2.y) {
        int add = (p1.x < p2.x ? 1 : -1);
        for (int j = p1.x+add; j != p2.x; j += add) {
            if (tab[j][p1.y] != '0') cnt ++;
        }
    } else
        cnt = 10;
    return cnt;
}

bool check()
{
    //true 合法, false 将死
    for (int i = 1; i <= n; i ++) {
        //printf("%c : %d %d %d %d\n", pos[i].t, pos[i].x, pos[i].y, pos[0].x, pos[0].y);
        if (pos[0].x == pos[i].x && pos[0].y == pos[i].y) continue;
        if (pos[i].t == 'G' || pos[i].t == 'R') {
            if (cnt(pos[0], pos[i]) == 0) return false;
        } else if (pos[i].t == 'C') {
            if (cnt(pos[0], pos[i]) == 1) return false;
        } else {
            for (int j = 0; j < 8; j ++) {
                if (pos[i].x + movH[j][0] == pos[0].x
                && pos[i].y + movH[j][1] == pos[0].y
                && tab[pos[i].x + mov[j/2][0]][pos[i].y + mov[j/2][1]] == '0')
                    return false;
            }
        }
    }
    return true;
}

void print()
{
    for (int i = 1; i <= 10; i ++) {
        for (int j = 1; j <= 9; j ++) {
            printf("%c ", tab0[i][j]);
        }
        printf("\n");
    }       
}       

int main(void)
{       
    while (scanf("%d%d%d", &n, &gnr.x, &gnr.y), n || gnr.x || gnr.y) {
        memset(tab0, '0', sizeof(tab0)); 
        tab0[gnr.x][gnr.y] = '1';
        for (int i = 1; i <= n; i ++) {
            char type[2];
            scanf("%s%d%d", type, &pos[i].x, &pos[i].y);
            pos[i].t = type[0];
            tab0[pos[i].x][pos[i].y] = pos[i].t;
        }
        //print();

        bool res = true; 
        for (int i = 0; i < 4; i ++) {
            memcpy(tab, tab0, sizeof(tab0)); 
            pos[0].x = gnr.x+ mov[i][0];
            pos[0].y = gnr.y + mov[i][1]; 
            if (!legal(pos[0].x, pos[0].y)) continue;
            tab[pos[0].x][pos[0].y] = '1';
            tab[gnr.x][gnr.y] = '0';
            if (check()) { res = false; break; }
        }       

        if (res) puts("YES");
        else puts("NO");
    }       

    return 0;
}习4-2 UVA 201 正方形

思路 
直接暴力搜索所有可能的正方形。此题数据较弱，如果数据强，可能需要用更好的方法。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 9;

int n;
bool a[N][N][2];
int num[N];

int check(int i, int j, int s)
{
    int flag = 1;
    for (int x = i; x < i+s; x ++)
        if (!a[x][j][1] || !a[x][j+s][1]) flag = 0;
    for (int y = j; y < j+s; y ++)
        if (!a[i][y][0] || !a[i+s][y][0]) flag = 0;
    return flag;
}

int main(void)
{
    int m, t = 0;
    while (scanf("%d", &n) != EOF) {
        cin >> m;
        memset(a, 0, sizeof(a));
        char c[2];
        int x, y;
        for (int i = 0; i < m; i ++) {
            scanf("%s%d%d", c, &x, &y);
            if (c[0] == 'H') a[x-1][y-1][0] = 1;
            else a[y-1][x-1][1] = 1;
        }

        if (t > 0) printf("\n**********************************\n\n");
        printf("Problem #%d\n\n", ++t);
        memset(num, 0, sizeof(num));
        bool flag = false;
        for (int s = 1; s < n; s ++) {
            for (int i = 0; i < n-s; i ++) {
                for (int j = 0; j < n-s; j ++) {
                    num[s] += check(i, j, s);
                }
            }
            if (num[s]) {
                flag = true;
                printf("%d square (s) of size %d\n", num[s], s);
            }
        }
        if (flag == false) printf("No completed squares can be found.\n");
    }

    return 0;
习4-3 UVA 220 黑白翻转棋

思路 
把示例数据过了紧接着提交就AC了。模拟题注意细节就好。只有真正自己写出来才能体会。 
代码

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

typedef pair<int, int> P;

char s[10][10];
char c;
int d[8][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1},
    {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};

bool legal(int x, int y)
{
    return 1 <= x && x <= 8 && 1 <= y && y <= 8;
}

char next()
{
    return c == 'W' ? 'B' : 'W';
}

bool check_dir(int x, int y, int i)
{
    if (s[x][y] != '-') return false;
    int nx = x + d[i][0];
    int ny = y + d[i][1];
    if (!legal(nx, ny) || s[nx][ny] != next())
        return false;
    while (true) {
        nx += d[i][0];
        ny += d[i][1];
        if (!legal(nx, ny) || s[nx][ny] == '-')
            return false;
        if (s[nx][ny] == c) return true;
    }
}
bool can_set(int x, int y)
{
    for (int i = 0; i < 8; i ++) {
        if (check_dir(x, y, i)) {
            return true;
        }
    }
    return false;
}

void set(int x, int y)
{
    for (int i = 0; i < 8; i ++) {
        if (check_dir(x, y, i)) {
            int nx = x+d[i][0], ny = y+d[i][1];
            while (s[nx][ny] == next()) {
                s[nx][ny] = c;
                nx += d[i][0];
                ny += d[i][1];
            }
        }
    }
    s[x][y] = c;
}

P cnt()
{
    P res(0, 0);
    for (int i = 1; i <= 8; i ++) {
        for (int j = 1; j <= 8; j ++) {
            if (s[i][j] == 'B') res.first ++;
            if (s[i][j] == 'W') res.second ++;
        }
    }
    return res;
}

void print_chess()
{
    for (int i = 1; i <= 8; i ++) {
        for (int j = 1; j <= 8; j ++) {
            printf("%c", s[i][j]);
        }
        printf("\n");
    }
}

int main(void)
{   
    int kase;
    char op[4];
    cin >> kase;
    for (int t = 1; t <= kase; t++) {
        for (int i = 1; i <= 8; i ++)
            scanf("%s", s[i]+1);
        scanf("%s", op);
        c = op[0];

        if (t > 1) printf("\n");
        while (scanf("%s", op)) {
            if (op[0] == 'L') {
                bool flag = false;
                bool first = true;
                for (int i = 1; i <= 8; i ++) {
                    for (int j = 1; j <= 8; j ++) {
                        if (can_set(i, j)) {
                            flag = true;
                            if (!first) printf(" ");
                            printf("(%d,%d)", i, j);
                            first = false;
                        } 
                    }
                }
                if (flag == false) printf("No legal move.");
                printf("\n");
            } else if(op[0] == 'M') {
                int x = op[1]-'0', y = op[2]-'0';
                if (can_set(x, y)) { set(x, y);}
                else { c = next(); set(x, y); }
                c = next();
                P num = cnt();
                printf("Black - %2d White - %2d\n", num.first, num.second);
            } else {
                print_chess();
                break;
            }
        }
    }

    return 0;
}
}习4-4 UVA 253 骰子涂色

思路 
判断等价，需要遍历所有状态。我这里定义了两种操作，一是往右转1/4圈roll_right，一是朝前的面往上转1/4圈roll_up。这两种操作足够遍历所有状态。 
具体遍历操作使用函数check_all_right_roll循环实现。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 10000;

int n, a[N];

void roll_right(char s[7])
{
    char c = s[1];
    s[1] = s[2];
    s[2] = s[4];
    s[4] = s[3];
    s[3] = c;
}

void roll_up(char s[7])
{
    char c = s[1];
    s[1] = s[5];
    s[5] = s[4];
    s[4] = s[0];
    s[0] = c;
}

bool check_all_right_roll(char s1[7], char s2[7])
{
    int res = false;
    for (int i = 0; i < 4; i ++) {
        roll_right(s1);
        if (strcmp(s1, s2) == 0) res = true;
    }
    return res;
}

int main(void)
{
    char s[13], s1[7], s2[7];
    while (scanf("%s", s) != EOF) {
        strncpy(s1, s, 6);
        s1[6] = '\0';
        strncpy(s2, s+6, 7);

        bool res = false;
        for (int i = 0; i < 4; i ++) {
            roll_up(s1);
            res |= check_all_right_roll(s1, s2);
        }
        roll_right(s1);
        roll_up(s1);
        res |= check_all_right_roll(s1, s2);
        roll_up(s1);
        roll_up(s1);
        res |= check_all_right_roll(s1, s2);

        if (res) puts("TRUE");
        else puts("FALSE");
    }

    return 0;
}习4-5 UVA 1590 互联网协议网络

思路 
考察二进制与十进制之间的转换。 
最小网络地址为最长公共前缀加上后面全部补零；子网掩码则为最长公共前缀对应的位全部置1，然后后面全部补零。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int n, c[32];

int main(void)
{
    while (cin >> n) {
        int x[4];
        memset(c, 0, sizeof(c));
        for (int k = 0; k < n; k ++) {
            scanf("%d.%d.%d.%d", &x[3], &x[2], &x[1], &x[0]);
            for (int i = 0; i < 4; i ++)
                for (int j = 0; j < 8; j ++)
                    c[i*8+j] += (x[i]&(1<<j)) ? 1 : 0;
        }
        int k = 32;
        for (k = 31; k >= 0; k --)
            if (c[k] != 0 && c[k] != n) break;

        memset(x, 0, sizeof(x));
        for (int i = 3; i >= 0; i --) {
            for (int j = 7; j >= 0; j --) {
                int k1 = i*8+j;
                if (k1 > k) x[i] |= ((c[k1]/n) << j);
            }
            printf("%d%c", x[i], (i == 0) ? '\n' : '.');
        }

        memset(x, 0, sizeof(x));
        for (int i = 3; i >= 0; i --) {
            for (int j = 7; j >= 0; j --) {
                int k1 = i*8+j;
                if (k1 > k) x[i] |= (1 << j);
            }
            printf("%d%c", x[i], (i == 0) ? '\n' : '.');
        }
    }

    return 0;
}习4-6 UVA 508 Morse Mismatches

思路 
首先这道题目紫书翻译错了。精确匹配的话应该输出第一个，而不是任意一个，如果有多个精确匹配，要加后缀“!”。未精确匹配的，不管是否有多个，都应该要加“?”。 
在检查匹配时，可以转为计算两段morse编码的距离。首先两段编码的公共长度前缀必须相同，否则距离为无穷。然后距离为两段编码长度之差。 
我的代码提交之后一直RE，查了很长时间才发现原因是：word数组定义成大小为100，而在while (cin >> word[n] && word[n][0] != ‘*’)这个地方n有可能是100，这样就超内存了。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

char morse[36][20];
int n;
string word[101];
string context[100];

int ctoi(char c)
{
    return isdigit(c) ? c-'0' : c-'A'+10;
}

void decode(string s)
{
    int resn = 0, resd = 80;
    string resc = "";
    int m = s.size();
    for (int i = 0; i < n; i++) {
        int k = context[i].size();
        int len = min(m, k);
        if (s.substr(0, len) == context[i].substr(0, len)) {
            int dis = abs(m-k);
            if (dis <= resd) {
                if (resd == 0)
                    resc = "!";
                else {
                    resn = i;
                    resd = dis;
                }
            }
        }
    }
    if (resd > 0) resc = "?";
    cout << word[resn] << resc << endl;
}

int main(void)
{
    char c[2];
    string s;
    while (cin >> c && c[0] != '*')
        cin >> morse[ctoi(c[0])];
    n = 0;
    while (cin >> word[n] && word[n][0] != '*') {
        for (int i = 0; word[n][i]; i++)
            context[n] += morse[ctoi(word[n][i])];
        n++;
    }
    while (cin >> s && s[0] != '*')
        decode(s);

    return 0;
}习4-7 UVA 509 RAID 技术

思路 
RAID技术的原理认真读一下原题，不难理解。这个题考察的是异或运算以及多层循环的组织。变量定义和流程详见代码。 
注意RAID数据保存出错的情况有两种： 
1、某列有x的情况下，只能有一个x，否则无法恢复数据。 
2、某列没有x的情况下，需要能通过校验。 
代码

#include<cstdio>
#include<cstring>
#include<string>
#include<iostream>
#include<algorithm>
using namespace std;

const int D = 6;
const int S = 64;
const int B = 100;

int main()
{
    int kase = 0;
    int d, s, b, e;
    char data[D][S*B+1];
    while (scanf("%d", &d) && d) {
        char c[2];
        scanf("%d%d%s", &s, &b, c);
        e = (c[0] == 'E') ? 0 : 1;
        for (int i = 0; i < d; i++)
            scanf("%s", data[i]);

        bool flag = true;
        for (int i = 0; i < b; i++) {
            for (int j = i*s; j < (i+1)*s; j++) {
                int cntx = 0;
                int x = d;
                int num = 0;
                for (int k = 0; k < d; k++) {
                    if (data[k][j] == 'x') {
                        cntx++;
                        x = k;
                    } else
                        num ^= (data[k][j] - '0');
                }
                if (cntx > 1 || x == d && num != e) { flag = false; break;}
                if (x < d) data[x][j] = (num ^ e) + '0';
            }
            if (flag == false) break;
        }

        if (flag == false) {
            printf("Disk set %d is invalid.\n", ++kase);
            continue;
        }

        int n = 0;
        char res[(D-1)*S*B+4];
        for (int i = 0; i < b; i++) {
            int p = i % d;
            for (int k = 0; k < d; k++) {
                if (k == p) continue;
                strncpy(res+n, data[k]+i*s, s);
                n += s;
            }
        }
        while (n % 4) res[n++] = '0';
        res[n] = '\0';

        printf("Disk set %d is valid, contents are: ", ++kase);
        for (int i = 0; i < n; i += 4) {
            int m = 0;
            for (int j = i; j < i+4; j++)
                m = m*2 + res[j] - '0';
            printf("%c", (m < 10) ? m+'0' : m-10+'A');
        }
        printf("\n");
    }

    return 0;
}习4-8 UVA 12108 特别困的学生 (特困生)

思路 
按照时间t一分一分往前走，每过一分钟检查一下学生的状态，每个学生如果到了睡眠-清醒状态变更的关键点时，检查是否满足变更条件。 
实验证明如果t超过500时全班还没有达到清醒则不存在全班清醒的时刻。当然这很可能是因为该题的数据比较弱。。 
代码

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int N = 10;

struct Stu {
    int a, b, c;

    bool is_sleep()
    {
        return c > a;
    }

    int next_minute(int m, bool can_sleep)
    {
        if (++c > a+b) {c = 1; m--;}
        else if (c == a+1) {
            if (can_sleep) m++;
            else c = 1;
        }
        return m;
    }
};

int main()
{
    int n, m, t;
    Stu s[N];
    int kase = 0;

    while (scanf("%d", &n) && n) {
        m = 0;
        for (int i = 0; i < n; i++) {
            scanf("%d%d%d", &s[i].a, &s[i].b, &s[i].c);
            if (s[i].is_sleep()) m++;
        }

        for (t = 1; t <= 500; t++) {
            if (m == 0) break;
            bool can_sleep = (m > n-m) ? 1 : 0;
            for (int i = 0; i < n; i++)
                m = s[i].next_minute(m, can_sleep);
        }

        if (m == 0) printf("Case %d: %d\n", ++kase, t);
        else printf("Case %d: -1\n", ++kase);
    }

    return 0;
}习4-9 UVA 1591 数据挖掘

思路 
认真的看了一遍却没看懂题意，看来的确如书中所说，对这个题兴趣不大。直接找了别人博客的分析参考着做的。 
特别抽象的一道题，给出数据总量n，数组p的元素大小sp，数组q元素大小sq，求使Qofs’(i)=(Pofs(i)+Pofs(i) < < A)>>B成立的A、B的值，和q数组占用的空间k。 
只需要从枚举32以内的A、B并判断是否合法即可，最终保留最小的k和使k最小的a、b。 
另可参考博客code4101的博文 
代码

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

typedef long long LL;

int main(){
    LL n, sp, sq;
    while (~scanf("%lld%lld%lld", &n, &sp, &sq)) {
        LL a, b, ansN = 1LL<<62, ansA = 0, ansB = 0;
        for (a = 0; a < 32; a++) {
            for(b = 0; b < 32; b++) {
              LL cur = (((n-1)*sp + ((n-1)*sp<<a)) >> b) + sq;
              if (cur >= n*sq && cur < ansN)
                ansN = cur, ansA = a, ansB = b;
            }
        }
        printf("%lld %lld %lld\n", ansN, ansA, ansB);
    }
    return 0;
}习4-10 UVA 815 洪水!

思路 
我看到这个题的第一想法就是二分法，这在紫书第八章才会介绍，但我在其它地方中已经学过了。具体是对水位的海拔高度做二分查找。 
在做的过程中WA了好几次，确实有一些特殊情况没有考虑到，边界情况处理，负数的处理等。

另外其它方法还有很多，比如这两种： 
1、把所有格子按海拔顺序排序，把每一档海拔与下一档之间能够容纳的水依次累加直到大于水的总体积。 
2、把所有格子按海拔顺序排序，逐个计算含水海拔，第n个格子的含水海拔=（总水量+n个格子相对于0海拔的体积）/n个格子的面积和，顺序读入后面格子海拔，如果此格高于已算出的含水海拔则终止。 
具体代码请参考其它博客。 
代码

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 30;
const double EPS = 1e-6;

int k;
int h[N*N];
int sum;

bool check(double mid)
{
    double res = 0;
    for (int i = 0; i < k; i ++)
        res += (mid > h[i]) ? (mid - h[i]) : 0;
    return res*100 >= sum;
}

int cnt(double mid)
{
    int res = 0;
    for (int i = 0; i < k; i ++)
        res += (mid > h[i]) ? 1 : 0;
    return res;
}

int main(void)
{
    int t = 0;
    int m, n;
    while (cin >> m >> n, m || n) {
        k = m*n;
        for (int i = 0; i < k; i ++)
            scanf("%d", &h[i]);
        cin >> sum;

        double ub = 1<<30, lb = -(1<<30);
        while (ub - lb > EPS) {
            double mid = (ub + lb) / 2;
            if (check(mid)) ub = mid;
            else lb = mid;
        }

        printf("Region %d\n", ++t);
        printf("Water level is %.2lf meters.\n", ub);
        printf("%.2lf percent of the region is under water.\n\n",
                (double)(cnt(ub))*100/m/n);
    }

    return 0;
算法竞赛入门经典(第二版)-刘汝佳-第五章 C++与STL 习题（13/16）


说明

本文是我对第五章16道习题的练习总结，建议配合紫书――《算法竞赛入门经典（第2版）》阅读本文。 
另外为了方便做题，我在VOJ上开了一个contest，欢迎一起在上面做：第五章习题contest 
如果想直接看某道题，请点开目录后点开相应的题目！！！

习题

习5-1 UVA 1593 代码对齐（vector）

思路 
此题的重点在于读入数据部分，读取每一行我用了getline，然后再用stringstream将该行数据分割成字符串vector数组。请读者自行看代码体会。 
输出就比较简单了，不足最大长度的用空格补齐。 
代码

#include <iostream>
#include <sstream>
#include <cstdio>
#include <cstring>
#include <string>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 1000;
const int LEN = 180;

int n;
vector<string> vs[N];
int w[LEN];

int main(void)
{
    n = 0;
    string line, s;
    memset(w, 0, sizeof(w));
    while (getline(cin, line)) {
        stringstream stm(line);
        int i = 0;
        while (stm >> s) {
            w[i] = max(w[i], (int)(s.size()));
            i ++;
            vs[n].push_back(s);
        }
        n ++;
    }

    for (int i = 0; i < n; i ++) {
        int k = vs[i].size();
        for (int j = 0; j < k-1; j ++) {
            cout << vs[i][j];
            for (int r = 0; r <= w[j]-vs[i][j].size(); r ++)
                printf(" ");
        }
        cout << vs[i][k-1] << endl;
    }   

    return 0;
}习5-2 UVA 1594 Ducci 队列

思路 
没看出来本题和本章主题C++与STL有什么联系。 
思路很简单，循环1000步，每步检查是否到终止条件（全0），提前达到终止条件则为ZERO，否则为LOOP。 
代码

#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 15;

int n, a[N];

bool is_zero()
{
    for (int i = 0; i < n; i ++) {
        if (a[i]) return false;
    }
    return true;
}

void change()
{
    int tmp = a[0];
    for (int i = 0; i < n-1; i ++)
        a[i] = abs(a[i] - a[i+1]);
    a[n-1] = abs(a[n-1] - tmp);
}

int main(void)
{
    int t;
    cin >> t;
    while (t --) {
        cin >> n;
        for (int i = 0; i < n; i ++)
            scanf("%d", &a[i]);

        int loop = 1001;
        while (loop--) {
            if (is_zero()) break;
            change();
        }

        if (is_zero()) puts("ZERO");
        else puts("LOOP");
    }

    return 0;
}习5-3 UVA 10935 卡片游戏（queue）

思路 
看题目描述就能知道是一个队列，具体细节看代码吧。 
代码

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <queue>
using namespace std;

int main(void)
{
    int n;
    while (cin >> n && n) {
        queue<int> q;
        for (int i = 1; i <= n; i ++)
            q.push(i);
        printf("Discarded cards:");
        while (q.size() > 2) {
            printf(" %d,", q.front());
            q.pop();
            q.push(q.front());
            q.pop();
        }
        if (q.size() == 2) {
            printf(" %d", q.front());
            q.pop();
        }
        printf("\n");
        printf("Remaining card:");
        printf(" %d\n", q.front());
    }

    return 0;
习5-4 UVA 10763 交流生（排序）

思路 
记P(A,B)表示一个想从A校换到B校的学生，数组a[N]和b[N]（元素类型为P）表示所有学生集合（初始内容相同）。 
定义两种比较函数：cmp1表示以元素first为第一排序依据，second为第二排序依据，排序顺序都是从小到大；cmp2则是以second为第一依据，first为第二依据。 
a和b分别用cmp1和cmp2排序后，如果a和b的任意第i个元素互相能对应起来，也就是满足代码中的条件： 
a[i].first == b[i].second && a[i].second == b[i].first 
则交换可以进行。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

typedef pair<int, int> P;

const int N = 500000;

int n;
P a[N], b[N];

bool cmp1(P p1, P p2)
{
    if (p1.first != p2.first) return p1.first < p2.first;
    return p1.second < p2.second;
}

bool cmp2(P p1, P p2)
{
    if (p1.second != p2.second) return p1.second < p2.second;
    return p1.first < p2.first;
}

int main(void)
{
    while (cin >> n && n) {
        for (int i = 0; i < n; i ++)
            scanf("%d%d", &a[i].first, &a[i].second);
        memcpy(b, a, sizeof(a));

        sort(a, a+n, cmp1);
        sort(b, b+n, cmp2);

        bool flag = true;
        for (int i = 0; i < n; i ++) {
            if (!(a[i].first == b[i].second && a[i].second == b[i].first))
            { flag = false; break;}
        }
        if (flag) puts("YES");
        else puts("NO");
    }

    return 0;
}习5-5 UVA 10391 复合词（查找、set）

思路 
有两种方法可以寻找复合词： 
1、枚举所有两个词的组合，查找是否则词典中； 
2、枚举所有词，拆分词为s1和s2查找是否都在词典中。 
词典的规模是120000，显然第二种时间复杂度低。 
尽管思路很清晰，但我还是WA了很多次，最后发现是因为在打印复合词之后未break，这可能导致某个复合词被打印多次。而这个错误在示例数据中检测不出来。

这个题也可以用set，代码写起来会简单一些。 
代码

#include <iostream>
#include <cstdio>
#include <string>
#include <algorithm>
using namespace std;

const int N = 120001;

int n;
string s[N];

int main(void)
{
    n = 0;
    while (cin >> s[n]) n++;
    s[n] = "";      

    string s1, s2;      
    for (int i = 0; i < n; i ++) {
        int m = s[i].size();            
        for (int j = 1; j < m; j ++) {          
            s1 = s[i].substr(0, j);                             
            s2 = s[i].substr(j);                                            
            int k1 = lower_bound(s, s+n, s1) - s;                                       
            int k2 = lower_bound(s, s+n, s2) - s;                                                   
            if (s[k1] == s1 && s[k2] == s2) {
              cout << s[i] << endl;
              break;
            }                                                                          
        }
    }

    return 0;
}习5-6 UVA 1595 对称轴（排序）

思路 
与5-4题有相似之处，也是两个cmp函数分别排序，检查排序后的数组是否匹配。详见代码中cmp函数以匹配的写法，读者自行体会。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

typedef pair<int, int> P;

const int N = 1000;

int n;
P a[N], b[N];

bool cmp1(P p1, P p2)
{
    if (p1.first != p2.first) return p1.first < p2.first;
    return p1.second < p2.second;
}

bool cmp2(P p1, P p2)
{
    if (p1.first != p2.first) return p1.first > p2.first;
    return p1.second < p2.second;
}

int main(void)
{
    int t;
    cin >> t;
    while (t --) {
        cin >> n;
        for (int i = 0; i < n; i ++)
            scanf("%d%d", &a[i].first, &a[i].second);
        memcpy(b, a, sizeof(a));

        sort(a, a+n, cmp1);
        sort(b, b+n, cmp2);

        int mid2 = a[0].first + a[n-1].first;

        bool flag = true;
        for (int i = 0; i <= n/2; i ++) {
            if (!(a[i].first + b[i].first == mid2 && a[i].second == b[i].second))
            { flag = false; break;}
        }
        if (flag) puts("YES");
        else puts("NO");
    }

    return 0;
}习5-7 UVA 12100 打印队列（queue）

思路 
这个题毫无疑问可以用队列实现，问题是如何判断某任务是否能够打印。 
根据题意，某任务能够打印的条件是队列中没有更优先的任务。由于优先级只有9个，我们可以定义一个元素个数为10的数组jobs，jobs[i]表示队列中优先级为i的任务的个数。每个任务打印后，其优先级i对应的jobs[i]减1。而优先级为i的任务能够打印得条件是对于所有大于i的j，job[j]均为0。 
还有一个小问题是每个任务如何在队列中表示？优先级信息k肯定是需要的，而且还需要知道任务的id（事实上我们只关心要求的那个id）。所以每个任务的信息可以用id*10+k表示。 
代码

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;

int jobs[10];
queue<int> q;

void init()
{
    memset(jobs, 0, sizeof(jobs));
    while(q.size()) q.pop();
}

bool can_print(int k)
{
    for (int i = k+1; i <= 9; i++) {
        if (jobs[i]) return false;
    }
    return true;
}

int main()
{
    int kase, n, m, k, t;
    scanf("%d", &kase);
    while (kase--) {
        scanf("%d%d", &n, &m);
        init();
        for (int i = 0; i < n; i++) {
            scanf("%d", &k);
            q.push(i*10 + k);
            jobs[k]++;
        }

        t = 0;
        while(q.size()) {
            k = q.front();
            q.pop();
            if (can_print(k%10)) {
                t++;
                jobs[k%10]--;
                if (k/10 == m) break;
            } else
                q.push(k);
        }
        printf("%d\n", t);
    }

    return 0;
}习5-8 UVA 230 图书管理系统（set、map）

思路 
本题涉及大量的有序插入和删除操作，用堆结构的set能够使时间复杂度最低（O(logN)）。 
介绍一下代码中使用的数据结构： 
set bks1表示架上图书集合； 
set bks2表示已归还但未上架的图书集合； 
map< string, string > mp表示标题与作者的映射； 
其它内容均体现在代码中。 
代码

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<set>
#include<map>
using namespace std;

struct Book {
    string name, author;
    bool operator< (Book b) const {
        if (author != b.author) return author < b.author;
        return name < b.name;
    }
};

map<string, string> mp;
set<Book> bks1;
set<Book> bks2;

int main()
{
    string s;
    Book b;
    while (getline(cin, s) && s != "END") {
        int k = s.find('"', 1);
        b.name = s.substr(0, k+1);
        b.author = s.substr(k+5);
        bks1.insert(b);
        mp[b.name] = b.author;
    }

    while (getline(cin, s) && s != "END") {
        if (s[0] == 'S') {
            set<Book>::iterator it1, it2;
            for (it2 = bks2.begin(); it2 != bks2.end(); it2++) {
                it1 = bks1.lower_bound(*it2);
                cout << "Put " << it2->name;
                if (bks1.empty() || it1 == bks1.begin())
                  cout << " first" << endl;
                else
                  cout << " after " << (--it1)->name << endl;
                bks1.insert(*it2);
            }
            bks2.clear();
            cout << "END" << endl;
        } else {
            b.name = s.substr(7);
            b.author = mp[b.name];
            if (s[0] == 'B')
              bks1.erase(b);
            else if (s[0] == 'R')
              bks2.insert(b);
        }
    }

    return 0;
}习5-9 UVA 1596 调试（map）

思路 
几个数据结构的说明： 
lens表示每个id（即数组）的长度； 
ids表示数组名对应的id； 
arrs表示每个数组中元素的赋值情况。

对于题意的说明： 
1、数组一定是定义过而且只定义过一次的； 
2、数组定义行的size部分是一个数字常量，数组中某元素的赋值行则不一定； 
3、bug只有两种情况：一是下标index越界，二是使用未初始化的变量（index和value都可能出现这种情况） 
代码

#include <iostream>
#include <sstream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
#include <vector>
using namespace std;

map<int, int> lens;
map<string, int> ids;
vector<map<int, int> > arrs;

void init_datas()
{
    lens.clear();
    ids.clear();
    arrs.clear();
}

int ID(string s)
{
    if (ids.count(s)) return ids[s];
    map<int, int> mp;
    arrs.push_back(mp);
    return ids[s] = arrs.size()-1;
}

int get_val(string s)
{
    int p = s.find('[');
    if (p == string::npos) return atoi(s.c_str());

    int sid = ID(s.substr(0, p));
    int id = get_val(s.substr(p+1, s.size()-p-2));
    if (id >= 0 && id < lens[sid] && arrs[sid].count(id))
        return arrs[sid][id];
    return -1;
}

bool have_bug(string s)
{
    int k = s.find('=');
    int sid, id, val;
    int p = s.find('[');
    sid = ID(s.substr(0, p));

    if (k == string::npos) {
        stringstream ss(s.substr(p+1));
        ss >> val;
        lens[sid] = val;
        return false;
    }

    id = get_val(s.substr(p+1, k-p-2));
    val = get_val(s.substr(k+1));
    if (id >= 0 && id < lens[sid] && val >= 0) {
        arrs[sid][id] = val;
        return false;
    }
    return true;
}

int main(void)
{
    string s;

    while (cin >> s && s != ".") {
        init_datas();
        int bug = 0, line = 0;
        do {
            line++;
            if (!bug && have_bug(s)) bug = line;
        } while (cin >> s && s != ".");
        printf("%d\n", bug);
    }

    return 0;
}习5-10 UVA 1597 在互联网中搜索（map、set、vector等）

思路 
本题直接按string查找会超时，可以将string映射到int后查找。 
除了NOT A的查找需要输出整篇文章，其它查找都是需要输出文章的对应行。 
由于查找时需要忽略大小写，可以定义两个变量数组，一个存储处理前的文章内容，一个存储处理后的。提取关键字有一个小技巧：可以把字符串中所有非英文字母化为空格。 
根据查询的关键字分别处理的过程，可以用到stl中的set_union和set_intersection函数进行求交集和并集。

另外，这题有一个很可笑的问题： 
原题中的样例输出竟然是错的，其中的’-‘只有九个，实际上能AC的程序应该是十个。 
准确的输出应该是：―――- 
代码

#include<cstdio>
#include<cstring>
#include<iostream>
#include<sstream>
#include<algorithm>
#include<string>
#include<vector>
#include<map>
#include<set>
#include<algorithm>
using namespace std;

const int N = 100;

int n;
vector<string> docs[N];
vector<set<int> > docs_ids[N];

map<string, int> str2id;
vector<string> id2str;

int ID(string s)
{
    if (str2id.count(s)) return str2id[s];
    id2str.push_back(s);
    return str2id[s] = id2str.size()-1;
}

int include_id(vector<set<int> >& ids, int id)
{
    for (int j = 0; j < ids.size(); j++) {
        if (ids[j].count(id)) return j;
    }
    return ids.size();
}

void print_doc(vector<string>& doc)
{
    for (int i = 0; i < doc.size(); i++)
        cout << doc[i] << endl;
}

bool comb(bool a, bool op, bool b)
{
    if (op) return a && b;
    return a || b;
}

int main()
{
    string s, s1, s2;

    cin >> n;
    getchar();
    for (int i = 0; i < n; i++) {
        while (getline(cin, s) && s != "**********") {
          docs[i].push_back(s);
          for (int j = 0; j < s.size(); j++) {
              if (isalpha(s[j])) s[j] = tolower(s[j]);
              else s[j] = ' ';
          }
          stringstream ss(s);
          set<int> st;
          while (ss >> s1)
              st.insert(ID(s1));
          docs_ids[i].push_back(st);
        }
    }

    int m, first;
    cin >> m;
    getchar();
    for (int i = 0; i < m; i++) {
        getline(cin, s);
        first = 1;
        if (s[0] == 'N') { //NOT A
            s = s.substr(4);
            for (int i = 0; i < n; i++) {
                vector<set<int> >& ids = docs_ids[i];
                int id = ID(s);
                if (include_id(ids, id) == ids.size()) {
                    if (!first) printf("----------\n");
                    print_doc(docs[i]);
                    first = 0;
                }
            }
        } else if (s.find(' ') == string::npos) { //key A
            for (int i = 0; i < n; i++) {
                vector<set<int> >& ids = docs_ids[i];
                int id = ID(s);
                int j = include_id(ids, id);
                if (j != ids.size()) {
                    if (!first) printf("----------\n");
                    for (; j < ids.size(); j++) {
                        if (ids[j].count(id))
                          cout << docs[i][j] << endl;
                    }
                    first = 0;
                }
            }
        } else {
            s1 = s.substr(0, s.find(' '));
            s2 = s.substr(s.rfind(' ')+1);
            bool op = (s.find("AND") != string::npos); //A AND B
            for (int i = 0; i < n; i++) {
                vector<set<int> >& ids = docs_ids[i];
                int id1 = ID(s1), id2 = ID(s2);
                int j1 = include_id(ids, id1);
                int j2 = include_id(ids, id2);
                if (comb(j1 != ids.size(), op, j2 != ids.size())) {
                    if (!first) printf("----------\n");
                    for (int j = min(j1, j2); j < ids.size(); j++) {
                        if (ids[j].count(id1) || ids[j].count(id2))
                          cout << docs[i][j] << endl;
                    }
                    first = 0;
                }
            }
        }
        if (first) printf("Sorry, I found nothing.\n");
        printf("==========\n");
    }

    return 0;
}习5-11 UVA 12504 更新字典（map）

思路 
此题重点有两个地方： 
1、输入的处理，我的方式详见代码； 
2、新增、删除、修改的判断，使用两个map分别表示两个字典，旧字典中键值在新字典中找不到表示删除，找到但修改了表示修改，新字典中键值在旧字典中找不到了表示新增。 
代码

#include<cstdio>
#include<cstring>
#include<iostream>
#include<sstream>
#include<map>
#include<vector>
#include<algorithm>
using namespace std;

typedef map<string, string> DICT;
DICT dict1, dict2;

void input_dict(DICT& dict)
{
    dict.clear();
    string s, key, value;
    getline(cin, s);
    for (int i = 0; i < s.size(); i++) {
        if (!isdigit(s[i]) && !isalpha(s[i]))
          s[i] = ' ';
    }
    stringstream ss(s);
    while (ss >> key >> value)
        dict[key] = value;
}

void print_keys(char ch, vector<string> vs)
{
    printf("%c", ch);
    for (int i = 0; i < vs.size(); i++)
      cout << vs[i] << ((i == vs.size()-1) ? '\n' : ',');
}

int main()
{
    int kase;
    cin >> kase;
    getchar();
    while (kase--) {
        input_dict(dict1);
        input_dict(dict2);

        vector<string> add, del, modi;
        DICT::iterator it1, it2;
        for (it1 = dict1.begin(); it1 != dict1.end(); it1++) {
            it2 = dict2.find(it1->first);
            if (it2 == dict2.end()) del.push_back(it1->first);
            else if (it2->second != it1->second) modi.push_back(it1->first);
        }
        for (it2 = dict2.begin(); it2 != dict2.end(); it2++) {
            it1 = dict1.find(it2->first);
            if (it1 == dict1.end()) add.push_back(it2->first);
        }

        if (add.size()) print_keys('+', add);
        if (del.size()) print_keys('-', del);
        if (modi.size()) print_keys('*', modi);
        if (!add.size() && !del.size() && !modi.size()) printf("No changes\n");
        printf("\n");
    }

    return 0;
}习5-12 UVA 511 Do You Know the Way to San Jose?（排序、map、sort、unique等）

思路 
题目并不难，但细节比较多，排序的依据有很多，比较容易出错。考差C++和STL也比较全面，比如结构体、构造函数、map、pair、vector、sort、unique等等，代码规范化会对该题有较大的帮助 。另外注意浮点数大小的比较方法。 
我的总体思路是先找出包含该地点的所有地图，对其area进行排序去重，找出详细等级为i对应的area（小于i则报错，这时也需要输出最详细的地图）。然后将包含该地点同时为相应area的地图按照题目描述进行排序，第一个就是所求。 
另外注意，书中对该题的描述有一处错误：最后一行的“或者包含它的地图总数超过i”应当改成“或者包含它的不同面积的地图种数低于i”。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <map>
#include <cmath>
using namespace std;

const double EPS = 1e-7;

typedef pair<double, double> P;

struct Map {
    string name;
    double x1, y1, x2, y2, area, d1, d2, d3;

    Map(){}
    Map(string _name, double _x1, double _y1, double _x2,
            double _y2) : name(_name), x1(_x1), y1(_y1), x2(_x2), y2(_y2) {
        if (x1 > x2) swap(x1, x2);
        if (y1 > y2) swap(y1, y2);
        area = (x2 - x1) * (y2 - y1);
    }

    void set_dis(P p)
    {
        double x = p.first, y = p.second;
        double xm = x - (x1 + x2)/2, ym = y - (y1 + y2)/2;
        d1 = xm*xm + ym*ym;
        d2 = (y2 - y1) / (x2 - x1) - 0.75;
        xm = x - x2, ym = y - y1;
        d3 = xm*xm + ym*ym;
    }

    bool contain(P p)
    {
        double x = p.first, y = p.second;
        return x1 <= x && x <= x2 && y1 <= y && y <= y2;
    }

    bool operator < (const Map& b) const {
        if (fabs(d1 - b.d1) > EPS) return d1 < b.d1;
        if (fabs(d2 - b.d2) > EPS) return d2 < b.d2;
        if (fabs(d3 - b.d3) > EPS) return d3 > b.d3;
        return x1 < b.x1;
    }
};

vector<Map> mps;
map<string, P> locas;

void search(string s, int n)
{
    cout << s << " at detail level " << n;
    if (!locas.count(s)) {
        cout << " unknown location\n";
        return;
    }

    P p = locas[s];
    vector<double> area;
    for (int i = 0; i < mps.size(); i++) {
        if (mps[i].contain(p)) {
            area.push_back(mps[i].area);
        }
    }
    if (area.empty()) {
        cout << " no map contains that location\n";
        return;
    }

    sort(area.begin(), area.end(), greater<double>());
    area.erase(unique(area.begin(), area.end()), area.end());
    if (area.size() < n) {
        cout << " no map at that detail level;";
        n = area.size();
    }

    vector<Map> cover;
    for (int i = 0; i < mps.size(); i++) {
        if (mps[i].contain(p) && fabs(mps[i].area - area[n-1]) <= EPS) {
            mps[i].set_dis(p);
            cover.push_back(mps[i]);
        }
    }   
    sort(cover.begin(), cover.end());
    cout << " using " << cover[0].name << endl;
}

int main(void)
{
    string s;
    double x1, x2, y1, y2;

    cin >> s; 
    while (cin >> s && s != "LOCATIONS") {
        cin >> x1 >> y1 >> x2 >> y2;
        mps.push_back(Map(s, x1, y1, x2, y2));
    }

    while (cin >> s && s != "REQUESTS") {
        cin >> x1 >> y1;
        locas[s] = P(x1, y1);
    }   

    int n;
    while (cin >> s && s != "END") {
        cin >> n;
        search(s, n);
    }   

    return 0;
}习5-13 UVA 822 客户中心（模拟，vector、map）

思路 
模拟题，这个题给我坑坏了，先是有两个判断条件没写好WA了两次，每次查错都花好久，但改了还是WA。我用udebug来调，利用上面生成的random数据来测试，始终总是约有20%与标准AC输出不一样。然后反复阅读自己写的程序，反复跟别人的AC程序对比，却怎么也找不到原因。后来发现udebug上给的标准AC输出竟然是错的！！！因为其输出跟别人能AC的程序的运行结果不一样！再后来我发现其实我的程序没注意的情况下，修改了一处漏掉的变量初始化部分后，其实提交后已经能够AC了！！这时候已经花了我将近两天时间！。。

牢骚完毕，讲一下这个题的整体思路： 
这是一道并不复杂的流程模拟题，注意看题抠细节，此题关键在于安排任务时是以人为主体还是以请求为循环主体。 
题目讲多个人同时选中某个请求时，选出上次处理时间最早的，否则就选出id最小的。乍一看感觉是要以请求为主体来找人的。但在头脑中想想会发现很复杂，因为在找到一个available的人的时候, 还需要跟其他available的人作对比，也就是说先要找出所有available的人, 再从这些人当中选出一个真正available的人来安排给他请求。 
解决这个问题的方案就是, 以人为循环主体来找请求（其实题目里也有明确的暗示了, 但是说的非常不明确）。按照题目的要求（两个要求, 自己定义一个比较函数）把存储人的数组先进行排序，对排序后的人依次找一个请求做就行了。而结束的时机是所有人都不在工作并且所有工作都分配完了。 
另外，有一个细节中文翻译交代的不清楚：不同请求的到来和处理是互相独立的，也就是说，对某一种请求，允许前一个请求还没处理完的情况下处理下一个请求（前提是下一个请求已经到来）。

最后，总结一下自己出错的地方： 
1、update()函数中，np不慎写成了nt，第一次提交报RE，已经怀疑过这个错误了，但检查的时候眼花了没看到。。 
2、忘记了每次主循环开始时Per结构体中tid数组的重新初始化。 
3、读入人的数据时，忘记对新写入结构体中的变量tproc做初始化，也就是这一行：per[i].tproc = 0;

代码

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<vector>
#include<map>
using namespace std;

struct Topic {
    int num, t0, t, dt;

    bool proc(int Time)
    {
        if (Time < t0 || num == 0) return false;
        num--;
        t0 += dt;
        return true;
    }

    bool finish(int Time)
    {
        return num == 0 && t0-dt+t <= Time;
    }
};

struct Person {
    int pid, k, last, tproc;
    vector<int> ti;

    bool operator < (const Person& p) const
    {
        if (last != p.last) return last < p.last;
        return pid < p.pid;
    }

    void proc(int t, int Time)
    {
        last = Time;
        tproc = t;
    }

    bool finish(int Time)
    {
        return last + tproc <= Time;
    }
};

int nt, np, Time;
Topic top[20];
Person per[5];

void choose_and_proc(Person& p)
{
    for (int j = 0; j < p.k; j++) {
        int i = p.ti[j];
        if (top[i].proc(Time)) {
            p.proc(top[i].t, Time);
            break;
        }
    }
}

void update()
{
    sort(per, per+np);
    for (int i = 0; i < np; i++) {
        Person& p = per[i];
        if (p.finish(Time)) choose_and_proc(p);
    }
}

bool topics_complete()
{
    //#define DEBUG
#ifdef DEBUG
    printf("Time %d -----\n", Time);
    for (int i = 0; i < nt; i++)
        printf("top%d: num=%d, t0=%d\n", i, top[i].num, top[i].t0);
    printf("-----\n");
    for (int i = 0; i < np; i++)
        printf("per%d: last=%d, tproc=%d\n", i, per[i].last, per[i].tproc);
    printf("==========\n\n");
#endif
    for (int i = 0; i < nt; i++)
        if (!top[i].finish(Time)) return false;
    for (int i = 0; i < np; i++)
        if (!per[i].finish(Time)) return false;
    return true;
}

int main()
{
    //freopen("in.txt", "r", stdin);
    int kase = 0;
    while (scanf("%d", &nt) && nt) {
        int tid;
        map<int, int> index;
        for (int i = 0; i < nt; i++) {
            scanf("%d%d%d%d%d", &tid, &top[i].num,
                    &top[i].t0, &top[i].t, &top[i].dt);
            index[tid] = i;
        }

        scanf("%d", &np);
        for (int i = 0; i < np; i++) {
            scanf("%d%d", &per[i].pid, &per[i].k);
            per[i].ti.clear();
            for (int j = 0; j < per[i].k; j++) {
                scanf("%d", &tid);
                per[i].ti.push_back(index[tid]);
            }
            per[i].last = -1;
            per[i].tproc = 0;
        }

        Time = 0;
        do {
            update(); 
            Time++;
        } while (!topics_complete());
        printf("Scenario %d: All requests are serviced within %d minutes.\n", ++kase, Time);   
    }

    return 0;
}习5-14 UVA 1598 交易所

思路 
以后有时间再做吧。 
代码

1
习5-15 UVA 12333 斐波那契的复仇

思路 
以后有时间再做吧。 
代码

1
习5-16 UVA 212 医疗设备利用

思路 
以后有时间再做吧。 
代码说明


算法竞赛入门经典(第二版)-刘汝佳-第六章 数据结构基础 习题（12/14）



本文是我对第六章14道习题的练习总结，建议配合紫书――《算法竞赛入门经典（第2版）》阅读本文。 
另外为了方便做题，我在VOJ上开了一个contest，欢迎一起在上面做：第六章习题contest 
如果想直接看某道题，请点开目录后点开相应的题目！！！

习题

习6-1 UVA 673 平衡的括号

思路 
这么简单的题目竟然错了3次，羞愧一下！注意各种细节的可能性，尤其是循环结束后stack应该为空！ 
给出一组测试数据，希望有帮助： 
3 
) 
() 
)( 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <stack>
using namespace std;

stack<char> st;

int main(void)
{
    int t;
    cin >> t;
    getchar();
    while (t --) {
        string s;
        getline(cin, s);
        while (st.size()) st.pop();
        bool res = true;
        for (int i = 0; i < s.size(); i ++) {
            char c = s[i];
            if (c == '(' || c == '[')
                st.push(c);
            else {
                if (st.empty() || c == ')' && st.top() != '('
                     || c == ']' && st.top() != '[') {
                    res = false;
                    break;
                } else
                    st.pop();
            }
        }
        if (res && st.empty()) puts("Yes");
        else puts("No");
    }

    return 0;

习6-2 UVA 712 S - 树

思路 
由查询可直接计算出叶子位置，对应方法为查询的二进制数转换为10进制数，但需要注意这个题x1 x2 … xN的顺序会有所改变，还需要加一步映射。详见代码。 
代码

#include <iostream>
#include <cstdio>
#include <cstring>
#include <string>
#include <algorithm>
using namespace std;

const int N = 7;

int n;
int order[N+1];
string leaf;

int main(void)
{
    int t = 0;
    while (cin >> n && n) {
        char s[N+1];
        for (int i = 0; i < n; i ++) {
            scanf("%s", s);
            order[i] = s[1]-'1';
        }
        cin >> leaf;

        string res;
        int k;
        cin >> k;
        while (k --) {
            scanf("%s", s);
            int m = 0;
            for (int i = 0; i < n; i ++)
                m = m*2 + s[order[i]]-'0';
            res += leaf[m];
        }
        printf("S-Tree #%d:\n", ++t);
        cout << res << endl;
        if (t) puts("");
    }

    return 0;
}习6-3 UVA 536 二叉树重建

思路 
首先可以将A-Z映射到0-25，这样数组链表就可以直接表示。 
根据两个不同序遍历的重建是比较简单的，主要思想是先序和后序的根分别在最前面和最后面，然后找出根在另一个序遍历中的位置，从而知道左子树和右子树的大小，从而递归建树。 
代码

#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <string>
using namespace std;

const int N = 26;

int lt[N+1], rt[N+1];

int c2d(char c)
{       
    return c - 'A' + 1;
}           

char d2c(int d)
{       
    return d - 1 + 'A';
}       

int rebuild(int n, int pre[], int in[])
{   
    if (n == 0) return 0;
    int root = pre[0];
    if (n == 1) {
        lt[root] = rt[root] = 0;
        return root;
    }
    int m;
    for (m = 0; m < n; m ++) {
        if (in[m] == root) break;
    }
    lt[root] = rebuild(m, pre+1, in);
    rt[root] = rebuild(n-m-1, pre+m+1, in+m+1);
    return root;
}

void post(int root)
{
    if (root == 0) return;
    post(lt[root]);
    post(rt[root]);
    printf("%c", d2c(root));
}

int main(void)
{
    int n;
    char s1[N+1], s2[N+1];
    int pre[N+1], in[N+1];
    while (scanf("%s%s", s1, s2) != EOF) {
        n = strlen(s1);
        for (int i = 0; i < n; i ++) {
            pre[i] = c2d(s1[i]);
            in[i] = c2d(s2[i]);
        }

        int root = rebuild(n, pre, in);
        post(root);
        printf("\n");
    }

    return 0;
}习6-4 UVA 439 骑士的移动

思路 
基本的BFS。需要注意两种特殊情况： 
1、起点与终点重合的情况； 
2、从起点无法到达终点的情况。 
我写程序时经常容易漏掉对第一种情况的判断。 
代码

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

const int N = 8;
const int INF = 0x3f3f3f3f;

typedef pair<int, int> P;

P bg, ed;

bool legal(int x, int y)
{
    return x >= 0 && x < N && y >= 0 && y < N;
}

int BFS()
{
    int d[N][N];
    for (int i = 0; i < N; i ++)
        for (int j = 0; j < N; j ++)
            d[i][j] = INF;

    queue <P> q;
    q.push(bg);
    d[bg.first][bg.second] = 0;
    while( q.size() ) {
        P p = q.front();
        q.pop();
        int x = p.first;
        int y = p.second;

        if (p == ed)
            return d[x][y];

        int pos[8][2] = {{1, 2}, {-1, 2}, {2, 1}, {2, -1},
            {1, -2}, {-1, -2}, {-2, 1}, {-2, -1}};
        for (int i = 0; i < 8; i ++) {
            int nx = x + pos[i][0];
            int ny = y + pos[i][1];
            if (legal(nx, ny) && d[nx][ny] == INF) {
                q.push(P(nx, ny));
                d[nx][ny] = d[x][y]+1;
            }
        }
    }

    return INF;
}

int main(void)
{
    char s1[3], s2[3];
    while (~scanf("%s%s", s1, s2)) {
        bg = P(s1[0]-'a', s1[1]-'1');
        ed = P(s2[0]-'a', s2[1]-'1');

        printf("To get from %s to %s takes %d knight moves.\n", s1, s2, BFS());
    }

    return 0;
}
}
}
}习6-5 UVA 1600 巡逻机器人

思路 
机器人要从一个m*n（1≤m，n≤20）网格的左上角(1,1)走到右下角(m,n)。网格中的一些格子是空地（用0表示），其他格子是障碍（用1表示）。机器人每次可以往4个方向走一格，但最多连续地穿越k（0≤k≤20）个障碍，求最短路长度。起点和终点保证是空地。

此题与例6-14 UVA 816 Abbott 的复仇思路上是非常类似的，都是以三维向量标识状态。不过这个题在实现细节上要比例题要简单。 
本题中(x, y, t)标识可能出现的某一状态，x表示横坐标，y表示纵坐标，t表示已经经过的障碍数，t不应当超过k。注意如果只用(x, y)来标识状态会出错。 
代码

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <vector>
#include <cstring>
using namespace std;

const int N = 20;
const int INF = 0x3f3f3f3f;

int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

struct Node {
    int x, y, t;
    int d;
    Node(){}
    Node(int xx, int yy, int tt) : x(xx), y(yy), t(tt){}
};

int m, n, k;
Node mp[N+1][N+1][N+1];
int v[N+1][N+1];
Node *bg, *ed;

void init_mp()
{
    for (int x = 1; x <= m; x ++) {
        for (int y = 1; y <= n; y ++) {
            int vv = 0;
            scanf("%d", &vv);
            v[x][y] = vv;
            for (int t = 0; t <= k; t ++) {
                mp[x][y][t].x = x;
                mp[x][y][t].y = y;
                mp[x][y][t].t = t;
                mp[x][y][t].d = INF;
            }
        }
    }
    bg = &mp[1][1][0];
    ed = &mp[m][n][0];
}

bool legal(int x, int y)
{
    return x >= 1 && x <= m && y >= 1 && y <= n;
}

int BFS()
{
    queue<Node*> que;
    que.push(bg);
    bg->d = 0;

    while( que.size() ) {
        Node *p = que.front();
        que.pop();
        //printf("%d,%d,%d,%d\n", p->x, p->y, p->t, p->d);

        if (p->x == ed->x && p->y == ed->y)
            return p->d;

        for (int i = 0; i < 4; i ++) {
            int nx = p->x + dir[i][0];
            int ny = p->y + dir[i][1];
            if (legal(nx, ny)) {
                int nt = v[nx][ny] ? p->t+1 : 0;
                Node *np = &mp[nx][ny][nt];
                if (np->d == INF && np->t <= k) {
                    np->d = p->d + 1;
                    que.push(np);
                }
            }
        }
    }
    return -1;
}

int main(void)
{
    int kase;
    scanf("%d", &kase);
    while (kase--) {
        scanf("%d%d%d", &m, &n, &k);
        init_mp();

        printf("%d\n", BFS());
    }

    return 0;
}习6-6 UVA 12166 修改天平

思路

代码

1
习6-7 UVA 804 Petri 网模拟

思路 
题意： 
你的任务是模拟Petri网的变迁。Petri网包含NP个库所（用P1，P2…表示）和NT个变迁（用T1，T2…表示）。0 < NP, NT<100。当每个变迁的每个输入库所都至少有一个token时，变迁是允许的。变迁发生的结果是每个输入库所减少一个token，每个输出库所增加一个token。变迁的发生是原子性的，即所有token的增加和减少应同时进行。注意，一个变迁可能有多个相同的输入或者输出。如果一个库所在变迁的输入库所列表中出现了两次，则token会减少两个。输出库所也是类似。如果有多个变迁是允许的，一次只能发生一个。 
输入一个Petri网络。初始时每个库所都有一个token。每个变迁用一个整数序列表示，负数表示输入库所，正数表示输出库所。每个变迁至少包含一个输入和一个输出。最后输入一个整数NF，表示要发生NF次变迁（同时有多个变迁允许时可以任选一个发生，输入保证这个选择不会影响最终结果）。

解法：循环模拟，对当前库所状态搜索所有变迁，当找到符合条件的变迁时（使变迁后所有库所包含的token都不低于0），即发生变迁。输入输出细节见代码。 
代码

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
using namespace std;

const int NP = 100;
const int NT = 100;

struct Node {
    int k;
    struct Node *next;
};

int np, nt, nf;
int p[NP], p1[NP], t[NT][NP];

int main()
{
    int kase = 0;
    while (scanf("%d", &np) && np) {
        for (int i = 1; i <= np; i++)
          scanf("%d", &p[i]);
        scanf("%d", &nt);
        memset(t, 0, sizeof(t));
        for (int i = 1; i <= nt; i++) {
            int j;
            while (scanf("%d", &j) && j) {
                if (j > 0) t[i][j]++;
                else t[i][-j]--;
            }
        }
        scanf("%d", &nf);

        int f = 1;
        for (; f <= nf; f++) {
            int i;
            for (i = 1; i <= nt; i++) {
                int j;
                for (j = 1; j <= np; j++) {
                    p1[j] = p[j]+t[i][j];
                    if (p1[j] < 0) break;
                }
                if (j > np) {
                    memcpy(p, p1, sizeof(p1));
                    break;
                }
            }
            if (i > nt) break;
        }

        if (f > nf) printf("Case %d: still live ", ++kase);
        else printf("Case %d: dead ", ++kase);
        printf("after %d transitions\nPlaces with tokens:", f-1);
        for (int i = 1; i <= np; i++)
            if (p[i] > 0) printf(" %d (%d)", i, p[i]);
        printf("\n\n");
    }

    return 0;
}习6-8 UVA 806 空间结构

思路 
题意： 
黑白图像有两种表示法：点阵表示和路径表示。路径表示法首先需要把图像转化为四分树，然后记录所有黑结点到根的路径。 
NW、NE、SW、SE分别用1、2、3、4表示。最后把得到的数字串看成是五进制的，转化为十进制后排序。例如上面的树在转化、排序后的结果是：9 14 17 22 23 44 63 69 88 94 113。 
你的任务是在这两种表示法之间进行转换。在点阵表示法中，1表示黑色，0表示白色。图像总是正方形的，且长度n为2的整数幂，并满足n≤64。输入输出细节请参见原题。

两种状态互转都需要用递归进行处理：

点阵转路径表示的情况。递归时判断当前区域包含的点是否全黑或全白，如果是则终止递归，并存储全黑叶节点对应的路径。其中递归时以字符串存储当前从根到该节点的路径。如果该区域包含的点有黑有白，则将当前区域分成4个递归处理，同时字符串加上当前路径。
路径转点阵表示的情况。递归时几乎是第一种情况的相反处理，但需要判断该节点是否是全黑叶节点，如果是则当前节点对应的区域全部置成’*’并终止递归。
另外本题需要注意一些输入输出的细节：

输出十进制时每个数字以空格分隔，但还要每12个数换行输出。
最后一个case后无空行。 
代码
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <vector>
#include <string>
#include <set>
using namespace std;

const int N = 64+1;

int n;
char area[N][N];
vector<int> nums;
set<string> strs;

bool same_color(int x0, int y0, int x1, int y1)
{
    char color0 = area[x0][y0];
    for (int i = x0; i < x1; i ++)
        for (int j = y0; j < y1; j ++)
            if (area[i][j] != color0) return false;
    return true;
}

int str2num(string s)
{
    int res = 0;
    for (int i = 0; i < s.size(); i++)
        res = res*5 + s[i]-'0';
    return res;
}

void get_nums(int x0, int y0, int x1, int y1, string s)
{
    if (same_color(x0, y0, x1, y1)) {
        if (area[x0][y0] == '1') nums.push_back(str2num(s));
        return;
    }
    int mx = (x0+x1) / 2;
    int my = (y0+y1) / 2;
    get_nums(x0, y0, mx, my, '1'+s);
    get_nums(x0, my, mx, y1, '2'+s);
    get_nums(mx, y0, x1, my, '3'+s);
    get_nums(mx, my, x1, y1, '4'+s);
}

void set_black(int x0, int y0, int x1, int y1)
{
    for (int i = x0; i < x1; i ++)
        for (int j = y0; j < y1; j ++)
            area[i][j] = '*';
}

string num2str(int num)
{
    string s;
    while (num) {
        char tmp = num%5 + '0';
        s = tmp + s;
        num /= 5;
    }
    return s;
}

void set_area(int x0, int y0, int x1, int y1, string s)
{
    if (strs.count(s)) {
        set_black(x0, y0, x1, y1);
        return;
    }
    if (x0 + 1 == x1 && y0 + 1 == y1) return;
    int mx = (x0+x1) / 2;
    int my = (y0+y1) / 2;
    set_area(x0, y0, mx, my, '1'+s);
    set_area(x0, my, mx, y1, '2'+s);
    set_area(mx, y0, x1, my, '3'+s);
    set_area(mx, my, x1, y1, '4'+s);
}

int main(void)
{
    //freopen("input", "r", stdin);
    int kase = 0;
    while (scanf("%d", &n) && n) {
        if (kase) printf("\n");
        printf("Image %d\n", ++kase);
        if (n > 0) {
            for (int i = 0; i < n; i++)
                scanf("%s", area[i]);
            nums.clear();
            get_nums(0, 0, n, n, "");
            sort(nums.begin(), nums.end());
            for (int i = 0; i < nums.size(); i++)
                printf("%d%c", nums[i], (i == nums.size()-1 || i % 12 == 11) ? '\n' : ' ');
            printf("Total number of black nodes = %d\n", nums.size());
        } else {
            n = -n;
            strs.clear();
            int x; 
            while (scanf("%d", &x) && x != -1)
                strs.insert(num2str(x));
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    area[i][j] = '.';
                }
                area[i][n] = '\0';
            }
            set_area(0, 0, n, n, "");
            for (int i = 0; i < n; i++)
                printf("%s\n", area[i]);
        }
    }

    return 0;
}习6-9 UVA 127 纸牌游戏

思路 
题意： 
把52张牌从左到右排好，每张牌自成一个牌堆（pile）。当某张牌与它左边那张牌或者左边第3张牌“match”（花色suit或者点数rank相同）时，就把这张牌移到那张牌上面。移动之后还要查看是否可以进行其他移动。只有位于牌堆顶部的牌才能移动或者参与match。当牌堆之间出现空隙时要立刻把右边的所有牌堆左移一格来填补空隙。如果有多张牌可以移动，先移动最左边的那张牌；如果既可以移一格也可以移3格时，移3格。按顺序输入52张牌，输出最后的牌堆数以及各牌堆的牌数。

数据结构：用双向链表+vector数组。用链表的原因是需要删除一部分节点（当然这个题目只有52个节点，直接用顺序结构估计也可以通过）。双向链表的删除操作更容易实现，而且这个题目同时需要向前和向后访问。vector数组用来存储每一堆纸牌。

代码架构：每次从头对链表中节点进行顺序搜索，如果其左数第三个节点与其花色或点数相同，则发生纸牌移动，并重新循环；如果左数第一个相同，则发生移动并重新循环；否则继续搜索。如果搜索到链表结尾仍然没有找到符合移动条件的，说明纸牌已经无法移动。 
但我的思路存在可优化的地方（只是已经AC了就懒得重新写）：发生纸牌移动后不需要从头再开始找，而是直接关注移动后的纸牌能否再次往前移动即可。 
代码

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

const int N = 52;

typedef pair<char, char> P;

vector<P> pile[N+1];
int pre[N+1], next[N+1];

void init()
{
    for (int i = 1; i <= N; i++) {
        pre[i] = i-1;
        next[i-1] = i;
        pile[i].clear();
    }
    pre[0] = N;
    next[N] = 0;
}

int pre3(int u)
{
    int cnt = 3;
    while (u && cnt) {
        u = pre[u];
        cnt--;
    }
    return u;
}

bool same_top(int u, int v)
{
    P a = pile[u][pile[u].size()-1];
    P b = pile[v][pile[v].size()-1];
    return a.first == b.first || a.second == b.second;
}

void del(int u)
{
    next[pre[u]] = next[u];
    pre[next[u]] = pre[u];
}

void move_top(int u, int v)
{
    int lenu = pile[u].size();
    P a = pile[u][lenu-1];
    pile[v].push_back(a);
    pile[u].resize(lenu-1);
    if (lenu-1 == 0) del(u);
}

int main(void)
{
    char s[3];
    while (scanf("%s", s) && strcmp(s, "#")) {
        init();
        for (int i = 1; i <= N; i++) {
            if (i > 1) scanf("%s", s);
            pile[i].push_back(P(s[0], s[1]));
        }

        while (true) {
            int u = next[0];
            while (u) {
                bool flag = true;
                int v = pre3(u);
                if (v && same_top(u, v)) move_top(u, v);
                else if ((v = pre[u]) && same_top(u, v)) move_top(u, v);
                else flag = false;
                if (flag) break;
                u = next[u];
            }
            if (!u) break;
        }

        vector<int> res;
        int u = next[0];
        while (u) {
            res.push_back(pile[u].size());
            u = next[u];
        }
        if (res.size() == 1) printf("1 pile remaining:");
        else printf("%d piles remaining:", res.size());
        for (int i = 0; i < res.size(); i++)
            printf(" %d", res[i]);
        printf("\n");
    } 

    return 0;
}   习6-10 UVA 246 10-20-30

思路 
题意： 
给52张的扑克堆，先从左往右发7张牌，之后连续不断从左往右发7张牌，如果有牌堆形成了以下3种情况（按顺序判断）：

头两张+尾一张和为10或20或30
头一张+尾两张和为10或20或30
尾三张和为10或20或30
就把这三张牌拿走，放到总牌堆底（这步要不断执行直到不再满足条件或牌堆没了)。如果有一个牌堆因为这个操作被取完了，那么以后将不在这个位置发牌。如果最后7个牌堆都可以消掉，那么赢，总牌堆用完，那么输，否则平（即不断循环）。问最后的输赢平，并输出步数。

解法： 
模拟，用一个vector记录下7个牌堆和总牌堆，这样就可以用set去记录状态了，然后每个牌堆用一个双端队列deque表示，这样满足可以从头也可以从尾巴取，不断模拟即可。

另外这个题我在做的过程中犯了两个比较大的错误：

在判断和为10或20或30时应当是循环判断，而不是只判断一次
保存当前状态时应当同时包括手中的牌和牌堆，我开始只保存了牌堆状态，结果出现了很隐蔽的错误（示例数据都能过，但是WA）
同时提供一组测试数据供参考： 
INPUT

2 6 5 10 10 4 10 10 10 4 5 10 4 5 10 9 7 6 1 7 6 9 5 3 10 10 4 10 9 2 1
10 1 10 10 10 3 10 9 8 10 8 7 1 2 8 6 1 2 3 5 7
4 3 2 10 8 10 6 8 9 5 8 10 5 3 5 4 6 9 9 1 7 6 3 5 10 10 8 10 9 10 10 7 10 1 10 10 10 3 10 9 8 10 8 7 1 2 8 6 7 3 3 8
10 5 4 3 5 7 10 8 2 3 9 10 8 4 5 1 7 6 7 2 6 9 10 2 3 10 3 4 4 9 10 1 1
10 1 10 10 10 3 10 9 8 10 8 7 1 2 8 6 7 3 3 8
4 3 2 10 8 10 6 8 9 5 8 10 5 3 5 4 6 9 9 1 7 6 3 5 10 10 8 10 9 10 10 7
10 1 10 10 10 3 10 9 8 10 8 7 1 2 8 6 1 2 3
0OUTPUT

Win : 180
Loss: 112
Loss: 118
Loss: 232代码

#include<cstdio>
#include<cstring>
#include<iostream>
#include<algorithm>
#include<deque>
#include<set>
#include<vector>
using namespace std;

typedef deque<int> PILE;
typedef vector<PILE> PILES;
PILES piles;

void init()
{
    piles.clear();
    for (int i = 0; i < 8; i++) {
        PILE p;
        piles.push_back(p);
    }
}

void solve()
{
    set<PILES> state;
    PILE& hand = piles[7];

    int cur = 0;
    while (hand.size()) {
        PILE& p = piles[cur];
        p.push_back(hand.front()); hand.pop_front();

        while (p.size() >= 3) {
            int n = p.size();
            if ((p[0]+p[1]+p[n-1]) % 10 == 0) {
                hand.push_back(p[0]);
                hand.push_back(p[1]);
                hand.push_back(p[n-1]);
                p.pop_front();
                p.pop_front();
                p.pop_back();
            } else if ((p[0]+p[n-2]+p[n-1]) % 10 == 0) {
                hand.push_back(p[0]);
                hand.push_back(p[n-2]);
                hand.push_back(p[n-1]);
                p.pop_front();
                p.pop_back();
                p.pop_back();
            } else if ((p[n-3]+p[n-2]+p[n-1]) % 10 == 0) {
                hand.push_back(p[n-3]);
                hand.push_back(p[n-2]);
                hand.push_back(p[n-1]);
                p.pop_back();
                p.pop_back();
                p.pop_back();
            } else break;
        }

        if (hand.size() == 52) {
            printf("Win : %d\n", state.size()+8);
            return;
        }

        if (hand.empty()) {
            printf("Loss: %d\n", state.size()+8);
            return;
        }

        if (state.count(piles)) {
            printf("Draw: %d\n", state.size()+8);
            return;
        }

        state.insert(piles);
        do {
            cur = (cur+1)%7;
        } while (piles[cur].empty());
    }
}

int main()
{
    int num;
    while (scanf("%d", &num) && num) {
        init(); 
        PILE& hand = piles[7];
        hand.push_back(num);
        for (int i = 0; i < 51; i++) {
            scanf("%d", &num);
            hand.push_back(num);
        }       
        for (int i = 0; i < 7; i++) {
            piles[i].push_back(hand.front()); hand.pop_front();
        }       

        solve();
    }       

    return 0;
}习6-11 UVA 10410 树重建

思路 
题意： 
输入一个n（n≤1000）结点树的BFS序列和DFS序列，你的任务是输出每个结点的子结点列表。输入序列（不管是BFS还是DFS）是这样生成的：当一个结点被扩展时，其所有子结点应该按照编号从小到大的顺序访问。

本以为与二叉树根据两种遍历重建树的过程完全类似，试了一下才发现大相径庭。 
在反复推演后，形成了本题的思路： 
基于BFS序列按层遍历，对于该层的节点在进行顺序访问时，应当在DFS序列中顺序相同（但可能中间隔着其它节点），一旦BFS中的节点在DFS中找不到对应的，说明已经到达树的下一层。 
按层遍历BFS序列时，其上层节点序列已经存储到set < int > upper中，访问该层的节点时，寻找其在DFS序列中向前找最近的出现在upper中的节点，这就是其父节点，将该节点归入其父节点的孩子集合中。 
最后对每个节点输出其孩子集合即可。

此题网上还有很多其他解法，有兴趣的读者请参考其他博客。 
代码

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <set>
#include <vector>
using namespace std;

const int N = 1001;

int n;
int bfs[N], dfs[N];
vector<int> children[N];

void get_tree()
{
    set<int> upper;
    upper.insert(bfs[1]);
    int begin = 2, i, j;
    while (begin <= n) {
        i = begin;
        j = 2;
        for (; i <= n; i++) {
            for (; j <= n; j++)
                if (dfs[j] == bfs[i]) break;
            if (j > n) break;
            for (int k = j-1; k >= 1; k--) {
                if (upper.count(dfs[k])) {
                    children[dfs[k]].push_back(bfs[i]);
                    break;
                }
            }
        }
        upper.clear();
        for (int k = begin; k < i; k++)
            upper.insert(bfs[k]);
        begin = i;
    }
}

int main(void)
{
    while (scanf("%d", &n) != EOF) {
        for (int i = 1; i <= n; i++)
            scanf("%d", &bfs[i]);
        for (int i = 1; i <= n; i++)
            scanf("%d", &dfs[i]);

        for (int i = 1; i <= n; i++)
            children[i].clear();
        get_tree();
        for (int i = 1; i <= n; i++) {
            printf("%d:", i);
            for (int j = 0; j < children[i].size(); j++)
                printf(" %d", children[i][j]);
            printf("\n");
        }
    }

    return 0;
}习6-12 UVA 810 筛子难题

思路 
题意是给出一个图，每个格子上都有一个数。然后给出一个起始位置，往这个位置上放一个骰子。然后给出这个骰子的初始状态，骰子的状态由两个数字表示，分别代表骰子顶面和正前面（从二维地图从下向上看为正前）的点数。如果骰子所在格子的相邻格子的数字等于当前骰子顶面的点数相同或者-1，那么骰子就可以滚动到这个格子上，如果格子的数字为0则表示该格子无法到达。要求求出一条路，使得骰子从起点出发能再走回起点，如果不存在，输出“No Solution Possible”。

其实就是个四维状态BFS，每个状态(x, y, t, f)表示(横坐标, 纵坐标, 顶面数字, 正前面数字)。实际山给定顶面数字和正前面数字就唯一的确定了一个筛子的状态。四个方向（上下左右）的翻滚中，左翻和右翻需要用打表法确定下一个状态。 
另外本题的输出格式略显复杂，详见代码。 
代码

#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
#include <vector>
#include <cstring>
using namespace std;

const int N = 10;
const int INF = 0x3f3f3f3f;

int dir[4][2] = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}}; //下右上左
int r[7][7];

struct Node {
    int x, y, t, f;
    int d;
    Node *pre;
};

int m, n;
Node mp[N+1][N+1][6+1][6+1];
int v[N+1][N+1];
Node *bg;

void init_right()
{
    memset(r, 0, sizeof(r));
    r[6][2] = r[2][1] = r[1][5] = r[5][6] = 4;
    r[6][5] = r[5][1] = r[1][2] = r[2][6] = 3;
    r[6][3] = r[3][1] = r[1][4] = r[4][6] = 2;
    r[6][4] = r[4][1] = r[1][3] = r[3][6] = 5;
    r[3][2] = r[2][4] = r[4][5] = r[5][3] = 6;
    r[3][5] = r[5][4] = r[4][2] = r[2][3] = 1;
}

void init_mp()
{
    for (int x = 1; x <= m; x ++) {
        for (int y = 1; y <= n; y ++) {
            scanf("%d", &v[x][y]);
            for (int t = 1; t <= 6; t ++) {
                for (int f = 1; f <= 6; f ++) {
                    mp[x][y][t][f].x = x;
                    mp[x][y][t][f].y = y;
                    mp[x][y][t][f].t = t;
                    mp[x][y][t][f].f = f;
                    mp[x][y][t][f].d = INF;
                    mp[x][y][t][f].pre = NULL;
                }
            }
        }
    }
}

bool legal(int x, int y)
{
    return x >= 1 && x <= m && y >= 1 && y <= n;
}

Node *BFS()
{
    queue<Node*> que;
    que.push(bg);
    bg->d = 0;

    bool first = true;
    while( que.size() ) {
        Node *p = que.front();
        que.pop();
        //printf("%d,%d,%d,%d\n", p->x, p->y, p->t, p->d);

        if (!first) {
            if (p->x == bg->x && p->y == bg->y)
                return p;
        } else
            first = false;

        for (int i = 0; i < 4; i ++) {
            int nx = p->x + dir[i][0];
            int ny = p->y + dir[i][1];
            if (legal(nx, ny) && (v[nx][ny] == -1 || v[nx][ny] == p->t)) {
                int nt, nf, t = p->t, f = p->f;
                if (i == 0) { //down
                    nt = 7-f; nf = t;
                } else if (i == 1) { //right
                    nt = 7-r[t][f]; nf = f;
                } else if (i == 2) { //up
                    nt = f; nf = 7-t;
                } else if (i == 3) { //left
                    nt = r[t][f]; nf = f;
                }
                Node *np = &mp[nx][ny][nt][nf];
                if (np->d == INF || np == bg) {
                    np->d = p->d + 1;
                    np->pre = p;
                    que.push(np);
                }
            }
        }
    }
    return NULL;
}

int main(void)
{   
    init_right();

    char name[21];
    while (scanf("%s", name) && strcmp(name, "END")) {
        int bx, by, bt, bf;
        scanf("%d%d%d%d%d%d", &m, &n, &bx, &by, &bt, &bf);
        init_mp();
        bg = &mp[bx][by][bt][bf];

        printf("%s\n", name);
        Node *p = BFS();
        if (p == NULL) printf("  No Solution Possible\n");
        else {
            typedef pair<int, int> P;
            vector<P> path; 
            while (p->pre != bg) {
                path.push_back(P(p->x, p->y)); 
                p = p->pre; 
            }   
            path.push_back(P(p->x, p->y));
            path.push_back(P(bg->x, bg->y));
            for (int i = path.size()-1; i >= 0; i--) {
                if ((path.size()-i)%9 == 1) printf("  ");
                printf("(%d,%d)", path[i].first, path[i].second);
                if (i != 0) printf(",");
                if ((path.size()-i)%9 == 0 || i == 0) printf("\n");
            }
        }
    }

    return 0;
}习6-13 UVA 215 电子表格计算器

思路 
题意： 
在一个R行C列（R≤20，C≤10）的电子表格中，行编号为A～T，列编号为0～9。按照行优先顺序输入电子表格的各个单元格。每个单元格可能是整数（可能是负数）或者引用了其他单元格的表达式（只包含非负整数、单元格名称和加减号，没有括号）。表达式保证以单元格名称开头，内部不含空白字符，且最多包含75个字符。 
尽量计算出所有表达式的值，然后输出各个单元格的值（计算结果保证为绝对值不超过10000的整数）。如果某些单元格循环引用，在表格之后输出（仍按行优先顺序）。

表格的引用类似于拓扑排序过程，如果出现循环引用则说明拓扑上存在圈。本来直接用书中例题的拓扑排序能解，但本题还要求输出所有无法计算的单元格，这个就需要对书中的排序算法做一点扩展，详见code。

这个题上折腾了挺长时间，为了帮助大家调试，特提供一组测试数据： 
INPUT

1 1
A0-A0
4 4
A1-A2+A3
A2
A3
B1+6
A3
4
A3-A2+6
B2+7-15+B1
1
2
3
4
C1-C3-C3-C3-15-C3
8
5
6
3 3
A1
A2
B0
B1
B2
C0
C1
C2
A0
3 3
A1
A2
B0
B1
B2
6
A1
C2
A1
6 6
1
A2
A0
C2
C4+C5+C2
B4-B3
2
A1
A1
A1
B0
B1
3
D5-C0+4
A2+B6-C0+E5+5
4
5
6
4
1
5
10
15
20
5
A2
A2
A2
A2
A3
6
B4
4
5
6
7
6 6
1
A2
A0
C2
C4+C5+C2
B4-B3
2
A1
A1
A1
B0
B1
3
D5-C0+4
A2+B5-C0+E5+5
4
5
6
4
1
5
10
15
20
5
A2
A2
A2
A2
A0
6
B4
4
5
6
7
0 0OUTPUT

A0: A0-A0

      0     1     2     3
A    10    10    10    10
B    10     4     6     2
C     1     2     3     4
D   -29     8     5     6

A0: A1
A1: A2
A2: B0
B0: B1
B1: B2
B2: C0
C0: C1
C1: C2
C2: A0

      0     1     2
A     6     6     6
B     6     6     6
C     6     6     6

A3: C2
A4: C4+C5+C2
C2: A2+B6-C0+E5+5
E5: A3

      0     1     2     3     4     5
A     1     1     1     5    16     1
B     2     1     1     1     2     1
C     3    21     5     4     5     6
D     4     1     5    10    15    20
E     5     1     1     1     1     1
F     6     2     4     5     6     7代码

#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

const int ROW = 20;
const int COL = 10;
const int N = ROW*COL;
const int MAX = 10000;

int row, col;
string tab[ROW][COL];

int n;
int c[N];
int val[N];
typedef pair<int, int> P;
vector<P> dep[N];

void prase_str(int i, int j)
{
    int k = i*col+j;
    string& s = tab[i][j];
    val[k] = 0;
    dep[k].clear();
    if (!isalpha(s[0])) {
        val[k] = atoi(s.c_str());
    } else {
        for (int h = 0; h < s.size(); h++) {
            if (isalpha(s[h]) || s[h] == '-' || s[h] == '+') {
                int sign = 1;
                if (s[h] == '-' || s[h] == '+') {
                    if (s[h] == '-') sign = -1;
                    h++;
                }
                if (isalpha(s[h]))
                  dep[k].push_back(P(sign, (s[h]-'A')*col + s[h+1]-'0'));
                else
                  val[k] += sign * atoi(s.substr(h).c_str());
            }
        }
    }
}

int dfs(int k)
{
    c[k] = -1;
    if (val[k] >= MAX) return MAX;
    for (int i = 0; i < dep[k].size(); i++) {
        int sign = dep[k][i].first;
        int u = dep[k][i].second;
        int v = 0;
        if (c[u] < 0 || (v = dfs(u)) >= MAX)
            return val[k] = MAX;
        val[k] += sign*v;
    }
    c[k] = 1;
    dep[k].clear();
    return val[k];
}

void toposort()
{
    memset(c, 0, sizeof(c));
    for (int i = 0; i < n; i++)
        dfs(i);
}

bool check_val()
{
    for (int i = 0; i < n; i++)
        if (val[i] >= MAX) return false;
    return true;
}

int main(void)
{
    //freopen("input", "r", stdin);
    while (scanf("%d%d", &row, &col), row || col) {
        n = row*col;
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                cin >> tab[i][j];
                prase_str(i, j);
            }
        }

        toposort();
        if (check_val()) {
            printf(" ");
            for (int j = 0; j < col; j++)
              printf("%6d", j);
            printf("\n");
            for (int i = 0; i < row; i++) {
                printf("%c", i+'A');
                for (int j = 0; j < col; j++) {
                    printf("%6d", val[i*col+j]);
                }
                printf("\n");
            }
        } else {
            for (int i = 0; i < row; i++) {
                for (int j = 0; j < col; j++) {
                    if (val[i*col+j] >= MAX) {
                        printf("%c%c: ", i+'A', j+'0');
                        cout << tab[i][j] << endl;
                    }
                }
            }
        }
        printf("\n");
    }

    return 0;
}习6-14 UVA 12118 检察员的难题

思路

代码


